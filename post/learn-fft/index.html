<!DOCTYPE html>
<html lang="en" dir="auto">

<head><meta charset="utf-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
<meta name="robots" content="index, follow">
<title>FFT &amp; NTT 学习笔记 | Roger Young</title>
<meta name="keywords" content="多项式" />
<meta name="description" content="FFT 怎么这么难啊。">
<meta name="author" content="rogeryoungh">
<link rel="canonical" href="https://rogeryoungh.github.io/blog/post/learn-fft/" />
<link crossorigin="anonymous" href="/blog/assets/css/stylesheet.min.db03f6b1db979d0cdd8e815f16121fd4c2bd956cb3c3efedeab38b2fb48ae6a7.css" integrity="sha256-2wP2sduXnQzdjoFfFhIf1MK9lWyzw&#43;/t6rOLL7SK5qc=" rel="preload stylesheet" as="style">
<link rel="preload" href="/blog/avatar.png" as="image">
<script defer crossorigin="anonymous" src="/blog/assets/js/highlight.min.dacf81874295cd2936dececc3a04b7a00adb5d68618e897914957eeeef6f03b8.js" integrity="sha256-2s&#43;Bh0KVzSk23s7MOgS3oArbXWhhjol5FJV&#43;7u9vA7g="
    onload="hljs.initHighlightingOnLoad();"></script>
<link rel="icon" href="https://rogeryoungh.github.io/blog/favicon.ico">
<link rel="icon" type="image/png" sizes="16x16" href="https://rogeryoungh.github.io/blog/favicon-16x16.png">
<link rel="icon" type="image/png" sizes="32x32" href="https://rogeryoungh.github.io/blog/favicon-32x32.png">
<link rel="apple-touch-icon" href="https://rogeryoungh.github.io/blog/apple-touch-icon.png">
<link rel="mask-icon" href="https://rogeryoungh.github.io/blog/safari-pinned-tab.svg">
<meta name="theme-color" content="#2e2e33">
<meta name="msapplication-TileColor" content="#2e2e33">
<meta name="generator" content="Hugo 0.92.1" />

<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.13.11/dist/katex.min.css">
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.13.11/dist/katex.min.js"></script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.13.11/dist/contrib/auto-render.min.js"
    onload="renderMathInElement(document.body);"></script>

<script>
    document.addEventListener("DOMContentLoaded", function () {
        renderMathInElement(document.body, {
            
            
            delimiters: [
                { left: '$$', right: '$$', display: true },
                { left: '$', right: '$', display: false },
                { left: '\\(', right: '\\)', display: false },
                { left: '\\[', right: '\\]', display: true }
            ],
            
            throwOnError: false
        });
    });
</script>




<meta property="og:title" content="FFT &amp; NTT 学习笔记" />
<meta property="og:description" content="FFT 怎么这么难啊。" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://rogeryoungh.github.io/blog/post/learn-fft/" /><meta property="article:section" content="post" />
<meta property="article:published_time" content="2021-07-22T00:00:00&#43;00:00" />
<meta property="article:modified_time" content="2021-07-22T00:00:00&#43;00:00" />

<meta name="twitter:card" content="summary"/>
<meta name="twitter:title" content="FFT &amp; NTT 学习笔记"/>
<meta name="twitter:description" content="FFT 怎么这么难啊。"/>


<script type="application/ld+json">
{
  "@context": "https://schema.org",
  "@type": "BreadcrumbList",
  "itemListElement": [, 
    {
      "@type": "ListItem",
      "position":  2 ,
      "name": "Posts",
      "item": "https://rogeryoungh.github.io/blog/post/"
    }, 
    {
      "@type": "ListItem",
      "position":  3 ,
      "name": "FFT \u0026 NTT 学习笔记",
      "item": "https://rogeryoungh.github.io/blog/post/learn-fft/"
    }
  ]
}
</script>
<script type="application/ld+json">
{
  "@context": "https://schema.org",
  "@type": "BlogPosting",
  "headline": "FFT \u0026 NTT 学习笔记",
  "name": "FFT \u0026 NTT 学习笔记",
  "description": "FFT 怎么这么难啊。",
  "keywords": [
    "多项式"
  ],
  "articleBody": "以下是我对 FFT 的感性理解，可能并不严谨，如有错误欢迎指正。\nFFT 以下讲述的算法是 Cooley–Tukey FFT，它在算法竞赛中使用的更为广泛。\n前置知识：复数，需要理解 Euler 公式。\n多项式乘法 对于 $n$ 次多项式\n$$ \\begin{aligned} f(x) = \\sum_{i=0}^n f_ix^i \u0026= f_0 + f_1 x + f_2x^2 + \\cdots + g_nx^n \\\\ g(x) = \\sum_{i=0}^n g_ix^i \u0026= g_0 + g_1 x + g_2x^2 + \\cdots + g_nx^n \\end{aligned} $$\n它们的卷积是 $F(x) = f(x) \\ast g(x) = (f \\ast g)(x) = \\sum\\limits_{k=0}^{2n} c_kx^k$，其中\n$$ c_k = \\sum_{i+j=k}f_ig_j $$\n因此朴素的计算多项式的卷积需要 $n^2$ 次系数乘法，我们需要优化。\n点值表示法 $n$ 次多项式 $f(x)$ 可以由 $n+1$ 个系数决定，也可以由 $n+1$ 个座标（点值）决定。即 $n$ 次多项式可以看作 $n+1$ 维的向量。\n考虑选取 $2n+1$ 个座标来确定 $f(x)$ 和 $g(x)$。则 $F(x)$ 可以简单的通过做 $2n+1$ 次乘法得到\n$$ (x_k,F(x_k)) = \\left(x_k, f(x_k)g(x_k)\\right) $$\n现在我们有了新的思路：先从系数表示法转换为点值表示法，做完乘法后再变回去。\nDFT 怎么把多项式转换成点值呢？我们有离散 Fourier 变换。\n称方程 $x^n = 1$ 的 $n$ 个解为单位根 $\\zeta_n$。对于给定的多项式 $f(x) = \\sum\\limits_{k=0}^{n-1} f_kx^k$ 和一个单位根 $\\zeta_n$，称向量\n$$ \\operatorname{DFT}_{\\zeta_n}(f) =( f(1), f(\\zeta_n^1), \\cdots, f(\\zeta_n^{n-1}) ) $$\n为 $f$ 的离散 Fourier 变换（Discrete Fourier Transform）。\nDFT 存在逆变换（IDFT），即从点值重新变回系数，仍是从向量到向量的变换。\nIDFT 具有一个关键性质\n$$ (\\operatorname{DFT}_{\\zeta})^{-1} = \\frac{1}{n} (\\operatorname{DFT}_{{\\zeta}^{-1}}) \\tag{1} $$\n我们将在后文证明它。现在我们可以统一的处理 DFT 和 IDFT。\n为了方便描述，接下来我们将把 $\\operatorname{DFT}_{\\zeta_n}$ 简单的记作 $\\mathcal{F}_n$。\n单位原根 至此，我们计算 DFT 的复杂度仍然是 $O(n^2)$，FFT 所迈出的关键一步是选取特殊的点加速计算。\n单位根中特殊的一个记作 $\\zeta_n = e^{\\frac{2 \\pi i}{n}}$，它叫做单位原根。依 Euler 公式，有\n$$ \\zeta_n = e^{\\tfrac{2 \\pi i}{n}} = \\cos \\left(\\frac{2\\pi}{n}\\right) + i \\sin \\left(\\frac{2\\pi}{n}\\right) $$\n即 $\\zeta_n$ 是单位圆上的一个点，全部的 $n$ 个单位根\n$$ x_k = \\zeta_n^k = e^{k\\tfrac{2 \\pi i}{n}} = \\cos \\left(\\frac{2\\pi k}{n}\\right) + i \\sin \\left(\\frac{2\\pi k}{n}\\right) $$\n恰对应到单位圆的 $n$ 等分点。因此根据 Euler 公式，单位根之间的乘法就是在单位圆上转圈圈。\n不难通过 Euler 公式验证单位原根 $\\zeta_n$ 的几条性质：\n $\\zeta_{2n}^{2k} = \\zeta_n^k$。 $\\zeta_{2n}^{n+k} = -\\zeta_{2n}^k$。  分治 利用单位原根的特殊性，我们可以分治计算 DFT。比如对于 $7$ 次多项式\n$$ \\begin{aligned} f(x) \u0026= f_0 + f_1x + f_2x^2 + f_3 x^3 + f_4 x^4 + f_5 x^5 + f_6 x^6 + f_7 x^7 \\\\ \u0026= (f_0 + f_2x^2 + f_4x^4 + f_6x^6) + x(f_1 + f_3x^2 + f_5x^4 + f_7x^6) \\end{aligned} $$\n奇偶分类\n$$ \\begin{aligned} f^{[0]}(x) \u0026= f_0 + f_2x + f_4x^2 + f_6x^3 \\\\ f^{[1]}(x) \u0026= f_1 + f_3x + f_5x^2 + f_7x^3 \\end{aligned} $$\n则原来的函数可以表示为\n$$ f(x) = f^{[0]}(x^2) + xf^{[1]}(x^2) $$\n一般的，对于度小于 $n$ 的多项式 $f(x)$，在单位根 $x = \\zeta_n^k$ 处的点值是\n$$ \\begin{aligned} f(\\zeta_n^k) \u0026= f^{[0]}(\\zeta_n^k \\cdot \\zeta_n^k) + \\zeta_n^kf^{[1]}(\\zeta_n^k \\cdot \\zeta_n^k) \\\\ \u0026= f^{[0]}(\\zeta_n^{2k}) + \\zeta_n^kf^{[1]}(\\zeta_n^{2k}) \\\\ \u0026= f^{[0]}(\\zeta_{n/2}^{k}) + \\zeta_n^kf^{[1]}(\\zeta_{n/2}^{k}) \\end{aligned} $$\n同理可得\n$$ \\begin{aligned} f(\\zeta_n^{k+n/2}) \u0026= f^{[0]}(\\zeta_n^{2k+n}) + \\zeta_n^{k+n/2}f^{[1]}(\\zeta_n^{2k+n}) \\\\ \u0026= f^{[0]}(\\zeta_{n/2}^{k}) - \\zeta_n^{k}f^{[1]}(\\zeta_{n/2}^{k}) \\end{aligned} $$\n在 DFT 中使用有\n$$ \\begin{aligned} \\mathcal{F}_n(f)[j] \u0026= \\mathcal{F}_{n/2}(f^{[0]})[j] + \\zeta_n^j \\mathcal{F}_{n/2}(f^{[1]})[j] \\\\ \\mathcal{F}_n(f)[j + n/2] \u0026= \\mathcal{F}_{n/2}(f^{[0]})[j] - \\zeta_n^j\\mathcal{F}_{n/2}(f^{[1]})[j] \\end{aligned} \\tag{2} $$\n因此我们需要把多项式的系数个数向上补到 $2^n$，方便分治。\n至此，我们可以写出递归版的 FFT。\nvoid fft(int n, img *f, int op) { static img tmp[1  18]; if (n == 1) return; for (int i = 0; i  n; i++) tmp[i] = f[i]; for (int i = 0; i  n; i++) { // 偶数放左边，奇数放右边  if (i \u0026 1) f[n / 2 + i / 2] = tmp[i]; else f[i / 2] = tmp[i]; } img *g = f, *h = f + n / 2; fft(n / 2, g, op), fft(n / 2, h, op); img w0 = {cos(2 * PI / n), sin(2 * PI * op / n)}, w = {1, 0}; for (int k = 0; k  n / 2; k++) { tmp[k] = g[k] + w * h[k]; tmp[k + n / 2] = g[k] - w * h[k]; w = w * w0; } for (int i = 0; i  n; i++) f[i] = tmp[i]; } 蝴蝶变换 递归分治总是不尽人意的，我们在前几行只是做了递归分组的事情，可以考虑一步到位。\n还是以 $7$ 次多项式为例\n 初始 $\\{x^0,x^1,x^2,x^3,x^4,x^5,x^6,x^7\\}$ 一次 $\\{x^0,x^2,x^4,x^6\\},\\{x^1,x^3,x^5,x^7\\}$ 两次 $\\{x^0,x^4\\},\\{x^2,x^6\\},\\{x^1,x^5\\},\\{x^3,x^7\\}$ 结束 $\\{x^0\\},\\{x^4\\},\\{x^2\\},\\{x^6\\},\\{x^1\\},\\{x^5\\},\\{x^3\\},\\{x^7\\}$  写出二进制的形式，可以发现：结束和开始的二进制恰好是相反的。\n   初始 0 1 2 3 4 5 6 7     初始(2) 000 001 010 011 100 101 110 111   结束(2) 000 100 010 110 001 101 011 111   结束 0 4 2 6 1 5 3 7    这个变换称为蝴蝶变换，也称位逆序置换（bit-reversal permutation）。\n我们可以 $O(n)$ 的预处理出变换数组。设 R(x) 是 $x$ 的变换结果，则 R(x  1) 此时是已知的。即是把 R(x  1) 右移一位再补上最高位即可。代码如下\nvoid pre_rev(int lim) { int k = std::__lg(lim); rev.resize(lim); for (int i = 0; i  lim; ++i) { rev[i] = rev[i  1]  1; if (i \u0026 1) rev[i] |= lim  1; // 或者合并写为  // rev[i] = (rev[i  1]  1) | ((i \u0026 1)  } } 现在我们可以写出非递归版的 FFT。\nvoid fft(img *f, int n, int op) { // DIT  for (int i = 0; i  n; ++i) if (i  rev[i]) swap(f[i], f[rev[i]]); for (int l = 1; l  n / 2; l  1) { img w0 = {cos(PI / l), sin(PI * op / l)}; for (int i = 0; i  n; i += l * 2) { img w = {1, 0}; for (int j = 0; j  l; j++) { img x = f[i + j], y = w * f[i + j + l]; f[i + j] = x + y, f[i + j + l] = x - y; w = w * w0; } } } if (op == -1) for (int i = 0; i  n; i++) f[i] = f[i] / n; } NTT 前置知识：数论基础（整除，同余）。\n用 double 去实现整数的乘法是很不优美的，精度、速度都很成问题。实际上，我们可以仅在整数下进行运算。\n原根 我们本质上用到的单位原根 $\\zeta_n$ 的两个性质是：\n $\\zeta_{n}^{n} = 1$。 $\\zeta_{2n}^{n} = -1$。  可以联想到模 $p$ 剩余类域 $\\mathbb{Z}_p$：其中的元素是 $\\{0,1,\\cdots,p-1\\}$，其上的运算都是模 $p$ 的。由于 Fermat 小定理\n$$ a^{\\varphi(p)} = a^{p-1} \\equiv 1 $$\n即从另一个角度说，$p-1$ 个正整数都是同余方程 $x^{p-1} \\equiv 1$ 的解。\n它和单位根有很相似的形式，直觉上 $\\mathbb{Z}_p$ 也存在类似单位原根的特殊数字。下面我们在 $\\mathbb{Z}_p$ 上讨论，尝试证明这个数字存在。\n定义正整数 $a \\in \\mathbb{Z}_p$ 的阶 $\\delta_p(a)$ 为最小的 $r$ 使得 $a^r \\equiv 1$。由 Fermat 小定理 $a^{\\varphi(p)} \\equiv 1$，因此 $a$ 的阶一定存在且有 $\\delta_p(a) \\mid \\varphi(p)$。可以证明\n$$ a,a^2,\\cdots a^{\\delta_p(a)} \\tag{3} $$\n在模 $p$ 下余数互不相同。由 Lagrange 定理，$x^{\\delta_p(a)} \\equiv 1$ 的解至多有 $\\delta_p(a)$ 个，恰是 $(3)$ 中所展示的。\n通过整除的性质，可以想到只有 $i \\bot \\delta_p(a)$ 才有 $\\delta_p(a^i) = \\delta_p(a)$，即 $a$ 总是附带着\n$$ \\sum_{i=1}^{\\delta_p(a)} [\\gcd(i, \\delta_p(a)) = 1] = \\varphi(\\delta_p(a)) $$\n个阶相同的东西。因此阶为 $\\delta_p(a)$ 的数恰有 $\\varphi(\\delta_p(a))$ 个。\n因为每个正整数都有唯一确定的阶，不妨假设对于所有 $d \\mid \\varphi(p)$，阶 $d$ 都存在 $\\varphi(d)$ 个对应的整数，统计整数个数\n$$ \\sum_{d \\mid \\varphi(p)} \\varphi(d) = \\varphi(p) = p - 1 $$\n恰为 $\\mathbb{Z}_p$ 全部正整数的个数，因此假设成立，也就存在 $a$ 使得 $\\delta_p(a) = p-1$。\n我们称这个 $a$ 是模 $p$ 下的一个原根，常用字母 $g$ 表示。\n快速数论变换 尽可能提取 $p - 1$ 的因子 $2$ 有\n$$ p = N q + 1, N = 2^m $$\n设 $\\mathbb{Z}_p$ 的一个原根 $g$，将 $g_N \\equiv g^q$ 看作 $\\zeta_n$ 的等价。利用二次剩余的知识不难得到 $g_N^N \\equiv 1$ 和 $g_N^{N/2} \\equiv -1$。\n常见的有\n$$ \\begin{aligned} p = 1004535809 = 479 \\times 2^{21} + 1\u0026, g = 3 \\\\ p = 998244353 = 7 \\times 17 \\times 2^{23} + 1\u0026, g = 3 \\end{aligned} $$\n类似的，我们可以写出程序\nvoid ntt(ll *f, int n, int type) { for (int i = 0; i  n; ++i) if (i  rev[i]) swap(f[i], f[rev[i]]); for (int h = 2; h  n; h  1) { ll tg = type == 1 ? 3 : g_inv; ll gn = qpow(tg, (P - 1) / h); for (int j = 0; j  n; j += h) { ll g = 1; for (int k = j; k  j + h / 2; k++) { ll f1 = f[k], f2 = g * f[k + h / 2] % P; f[k] = (f1 + f2) % P; f[k + h / 2] = (f1 - f2 + P) % P; g = g * gn % P; } } } ll iv_n = qpow(n); if (type == -1) for (int i = 0; i  n; i++) f[i] = f[i] * iv_n % P; } 至此，你已经学会 FFT 了。下面我们将更深入的从数学角度研究 FFT，补足理论基础。\n线性变换 DFT 是一个线性变换。换句话说，它可以被写成矩阵乘法的形式\n$$ \\begin{bmatrix} f(\\zeta_n^0) \\\\ f(\\zeta_n^1) \\\\ f(\\zeta_n^2) \\\\ \\vdots \\\\ f(\\zeta_n^{n-1}) \\end{bmatrix} = \\begin{bmatrix} 1 \u0026 1 \u0026 1 \u0026 \\cdots \u0026 1 \\\\ 1 \u0026 \\zeta_n^1 \u0026 \\zeta_n^2 \u0026 \\cdots \u0026 \\zeta_n^{n-1} \\\\ 1 \u0026 \\zeta_n^2 \u0026 \\zeta_n^4 \u0026 \\cdots \u0026 \\zeta_n^{2(n-1)} \\\\ \\vdots \u0026 \\vdots \u0026 \\vdots \u0026 \\ddots \u0026 \\vdots \\\\ 1 \u0026 \\zeta_n^{n-1} \u0026 \\zeta_n^{2(n-1)} \u0026 \\cdots \u0026 \\zeta_n^{(n-1)^2} \\end{bmatrix} \\begin{bmatrix} f_0 \\\\ f_1 \\\\ f_2 \\\\ \\vdots \\\\ f_{n-1} \\end{bmatrix} $$\n我们把中间的那个 $n$ 阶的 Vandermonde 方阵记为 $V(\\zeta_n) = (\\zeta_n^{ij})$。\n直接计算 $V(\\zeta_n)$ 的逆很不好算，但是验证下式是对角矩阵还是容易的\n$$ V(\\zeta_n) V(\\zeta_n^{-1}) = (n[i = j]) = n I_n $$\n即 IDFT 所对应的矩阵为 $V^{-1}(\\zeta_n) = \\frac{1}{n} V(\\zeta_n^{-1})$，我们便证明了 $(1)$ 式。\n干掉 REV 其实上文所实现的 FFT 和 IFFT 并不对偶，只是卷积定理使得 IFFT 恰是 FFT 的逆运算。具体的说，我们实现了两个 DIT，因此需要在计算之前进行蝴蝶变换。\n我们运算的核心内容在于 $(2)$ 式，它可以被写做矩阵形式。\n$$ \\begin{bmatrix} O_1 \\\\ O_2 \\end{bmatrix} = \\begin{bmatrix} 1 \u0026 \\zeta_n^{-j} \\\\ 1 \u0026 -\\zeta_n^{-j} \\end{bmatrix} \\begin{bmatrix} I_1 \\\\ I_2 \\end{bmatrix} $$\n对矩阵求逆\n$$ \\begin{bmatrix} I_1 \\\\ I_2 \\end{bmatrix} = \\frac{1}{2} \\begin{bmatrix} 1 \u0026 1 \\\\ \\zeta_n^{j} \u0026 -\\zeta_n^{j} \\end{bmatrix} \\begin{bmatrix} O_1 \\\\ O_2 \\end{bmatrix} \\tag{4} $$\n我们便得到了 DIF。类似的，我们可以实现两个 DIF 作为 FFT，此时蝴蝶变换在计算之后。\nvoid fft(img *f, int n, int op) { // DIF  for (int l = n / 2; l = 1; l = 1) { img w0 = {cos(PI / l), sin(PI * op / l)}; for (int i = 0; i  n; i += l * 2) { img w = {1, 0}; for (int j = 0; j  l; j++) { img x = f[i + j], y = f[i + j + l]; f[i + j] = x + y, f[i + j + l] = w * (x - y); w = w * w0; } } } for (int i = 0; i  n; ++i) if (i  rev[i]) swap(f[i], f[rev[i]]); if (op == -1) for (int i = 0; i  n; i++) f[i] = f[i] / n; } 容易发现，若我们以 DIF 作为 FFT，DIT 作为 IFFT，是不需要蝴蝶变换的。\nvoid fft(img *f, int n) { for (int l = n / 2; l = 1; l = 1) { img w0 = {cos(PI / l), sin(PI / l)}; for (int i = 0; i  n; i += l * 2) { img w = {1, 0}; for (int j = 0; j  l; j++) { img x = f[i + j], y = f[i + j + l]; f[i + j] = x + y, f[i + j + l] = w * (x - y); w = w * w0; } } } } void ifft(img *f, int n) { for (int l = 1; l  n / 2; l  1) { img w0 = img{cos(PI / l), sin(PI / l)}.conj(); for (int i = 0; i  n; i += l * 2) { img w = {1, 0}; for (int j = 0; j  l; j++) { img x = f[i + j], y = w * f[i + j + l]; f[i + j] = x + y, f[i + j + l] = x - y; w = w * w0; } } } for (int i = 0; i  n; i++) f[i] = f[i] / n; } 以上，便是 Twisted FFT。\n另一种理解 注意到\n$$ f(x_0) = f \\bmod (x - x_0) $$\n我们可以从这方面着手，从取模角度重新审视上述算法。假设 $f$ 可以被分解为\n$$ f = (x^n - r)(x^n + r)f_{0} + (x^n - r)f_{1} + (x^n + r)f_{2} + f_3 $$\n令\n$$ \\begin{aligned} O_1 \u0026= f \\bmod (x^n + r) = -2r f_1 + f_3\\\\ O_2 \u0026= f \\bmod (x^n - r) = 2r f_2 + f_3 \\end{aligned} $$\n故\n$$ f \\bmod (x^{2n} - r^2) = \\frac{O_2-O_1}{2r}x^n + \\frac{O_2 + O_1}{2} = I_1 x^n + I_2 $$\n注意到代码中我们并没有直接求 $O_1$，而是对第 $j$ 位乘上了 $\\zeta_{2n}^j$，即求的是 $f(\\zeta_{2n}x)$。\n可以发现\n$$ f(\\zeta_{2n}x) \\bmod (x^n-1) = f(\\zeta_{2n}x) \\bmod ((\\zeta_{2n} x)^n - 1) = f(x) \\bmod (x^n + 1) $$\n这个图并不好理解，下面那张 Original FFT 更容易理解，但是现在广为流传的算法是 Twisted FFT。\n通过图可以看出，FFT 的过程即是先把多项式从根推到叶子，即求得所有单位根处的值，做完操作后，再从叶子推回根。\nOriginal FFT 当然，我们可以直接分治，便是 Original FFT。\n由于篇幅有限，本文不展开。\n预处理单位根 每次计算都重新计算一遍单位根太浪费了，我们可以预处理它，从而在计算中调用。\nvectorimg ROOT; void init(int n) { static int lim = (ROOT = {{1, 0}}, 1); if (lim = n) return; ROOT.resize(n); for (int l = lim; l  n; l *= 2) { img w = {cos(PI / l / 2), sin(PI / l / 2)}; ROOT[l] = w; for (int i = 1; i  l; ++i) ROOT[i + l] = ROOT[i] * w; } lim = n; } 其他应用 FFT 实际上是一个工具，用于快速计算卷积，这篇文章我想更聚焦于理解 FFT 的计算过程。\nFFT 还有很多应用，比如快速加法，带通配文本匹配等，后面等再刷些题了可能会开一篇讲一讲这个，现在我积累的还不够。\nRefence  OI-Wiki 快速傅里叶变换 FFT 入门笔记 - hly1024  ",
  "wordCount" : "1890",
  "inLanguage": "en",
  "datePublished": "2021-07-22T00:00:00Z",
  "dateModified": "2021-07-22T00:00:00Z",
  "author":{
    "@type": "Person",
    "name": "rogeryoungh"
  },
  "mainEntityOfPage": {
    "@type": "WebPage",
    "@id": "https://rogeryoungh.github.io/blog/post/learn-fft/"
  },
  "publisher": {
    "@type": "Organization",
    "name": "Roger Young",
    "logo": {
      "@type": "ImageObject",
      "url": "https://rogeryoungh.github.io/blog/favicon.ico"
    }
  }
}
</script>
</head>

<body class="" id="top">
<script>
    if (localStorage.getItem("pref-font") === "serif") {
        document.body.classList.add('serif');
    }

</script>
<script>
    if (localStorage.getItem("pref-theme") === "dark") {
        document.body.classList.add('dark');
    } else if (localStorage.getItem("pref-theme") === "light") {
        document.body.classList.remove('dark')
    } else if (window.matchMedia('(prefers-color-scheme: dark)').matches) {
        document.body.classList.add('dark');
    }

</script>
<noscript>
    <style type="text/css">
        #theme-toggle,
        .top-link {
            display: none;
        }

    </style>
    <style>
        @media (prefers-color-scheme: dark) {
            :root {
                --theme: #1d1e20;
                --entry: #2e2e33;
                --primary: rgba(255, 255, 255, 0.84);
                --secondary: rgba(255, 255, 255, 0.56);
                --tertiary: rgba(255, 255, 255, 0.16);
                --content: rgba(255, 255, 255, 0.74);
                --hljs-bg: #2e2e33;
                --code-bg: #37383e;
                --border: #333;
            }

            .list {
                background: var(--theme);
            }

            .list:not(.dark)::-webkit-scrollbar-track {
                background: 0 0;
            }

            .list:not(.dark)::-webkit-scrollbar-thumb {
                border-color: var(--theme);
            }
        }

    </style>
</noscript>

<header class="header">
    <nav class="nav">
        <div class="logo">
            <a href="https://rogeryoungh.github.io/blog" accesskey="h" title="Roger Young (Alt + H)">Roger Young</a>
            <span class="logo-switches">
                <button id="theme-toggle" accesskey="t" title="(Alt + T)">
                    <svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24"
                        fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"
                        stroke-linejoin="round">
                        <path d="M21 12.79A9 9 0 1 1 11.21 3 7 7 0 0 0 21 12.79z"></path>
                    </svg>
                    <svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24"
                        fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"
                        stroke-linejoin="round">
                        <circle cx="12" cy="12" r="5"></circle>
                        <line x1="12" y1="1" x2="12" y2="3"></line>
                        <line x1="12" y1="21" x2="12" y2="23"></line>
                        <line x1="4.22" y1="4.22" x2="5.64" y2="5.64"></line>
                        <line x1="18.36" y1="18.36" x2="19.78" y2="19.78"></line>
                        <line x1="1" y1="12" x2="3" y2="12"></line>
                        <line x1="21" y1="12" x2="23" y2="12"></line>
                        <line x1="4.22" y1="19.78" x2="5.64" y2="18.36"></line>
                        <line x1="18.36" y1="5.64" x2="19.78" y2="4.22"></line>
                    </svg>
                </button>
                <button id="font-toggle" accesskey="t" title="(Alt + T)">A</button>
            </span>
        </div>
        <ul id="menu">
            <li>
                <a href="https://rogeryoungh.github.io/blog/archives" title="Archive">
                    <span>Archive</span>
                </a>
            </li>
            <li>
                <a href="https://rogeryoungh.github.io/blog/search/" title="Search (Alt &#43; /)" accesskey=/>
                    <span>Search</span>
                </a>
            </li>
            <li>
                <a href="https://rogeryoungh.github.io/blog/about/" title="About">
                    <span>About</span>
                </a>
            </li>
        </ul>
    </nav>
</header>
<main class="main">

<article class="post-single">
  <header class="post-header">
    
    <h1 class="post-title">
      FFT &amp; NTT 学习笔记
    </h1>
    <div class="post-meta">July 22, 2021&nbsp;·&nbsp;rogeryoungh
</div>
  </header> <div class="toc">
    <details >
        <summary accesskey="c" title="(Alt + C)">
            <div class="details">Table of Contents</div>
        </summary>
        <div class="inner"><ul>
                <li>
                    <a href="#fft" aria-label="FFT">FFT</a><ul>
                        
                <li>
                    <a href="#%e5%a4%9a%e9%a1%b9%e5%bc%8f%e4%b9%98%e6%b3%95" aria-label="多项式乘法">多项式乘法</a></li>
                <li>
                    <a href="#%e7%82%b9%e5%80%bc%e8%a1%a8%e7%a4%ba%e6%b3%95" aria-label="点值表示法">点值表示法</a></li>
                <li>
                    <a href="#dft" aria-label="DFT">DFT</a></li>
                <li>
                    <a href="#%e5%8d%95%e4%bd%8d%e5%8e%9f%e6%a0%b9" aria-label="单位原根">单位原根</a></li>
                <li>
                    <a href="#%e5%88%86%e6%b2%bb" aria-label="分治">分治</a></li>
                <li>
                    <a href="#%e8%9d%b4%e8%9d%b6%e5%8f%98%e6%8d%a2" aria-label="蝴蝶变换">蝴蝶变换</a></li></ul>
                </li>
                <li>
                    <a href="#ntt" aria-label="NTT">NTT</a><ul>
                        
                <li>
                    <a href="#%e5%8e%9f%e6%a0%b9" aria-label="原根">原根</a></li>
                <li>
                    <a href="#%e5%bf%ab%e9%80%9f%e6%95%b0%e8%ae%ba%e5%8f%98%e6%8d%a2" aria-label="快速数论变换">快速数论变换</a></li></ul>
                </li>
                <li>
                    <a href="#%e7%ba%bf%e6%80%a7%e5%8f%98%e6%8d%a2" aria-label="线性变换">线性变换</a><ul>
                        
                <li>
                    <a href="#%e5%b9%b2%e6%8e%89-rev" aria-label="干掉 REV">干掉 REV</a></li>
                <li>
                    <a href="#%e5%8f%a6%e4%b8%80%e7%a7%8d%e7%90%86%e8%a7%a3" aria-label="另一种理解">另一种理解</a></li>
                <li>
                    <a href="#original-fft" aria-label="Original FFT">Original FFT</a></li>
                <li>
                    <a href="#%e9%a2%84%e5%a4%84%e7%90%86%e5%8d%95%e4%bd%8d%e6%a0%b9" aria-label="预处理单位根">预处理单位根</a></li>
                <li>
                    <a href="#%e5%85%b6%e4%bb%96%e5%ba%94%e7%94%a8" aria-label="其他应用">其他应用</a></li></ul>
                </li>
                <li>
                    <a href="#refence" aria-label="Refence">Refence</a>
                </li>
            </ul>
        </div>
    </details>
</div>

  <div class="post-content"><p>以下是我对 FFT 的感性理解，可能并不严谨，如有错误欢迎指正。</p>
<h2 id="fft">FFT<a hidden class="anchor" aria-hidden="true" href="#fft">#</a></h2>
<p>以下讲述的算法是 Cooley–Tukey FFT，它在算法竞赛中使用的更为广泛。</p>
<p>前置知识：复数，需要理解 Euler 公式。</p>
<h3 id="多项式乘法">多项式乘法<a hidden class="anchor" aria-hidden="true" href="#多项式乘法">#</a></h3>
<p>对于 $n$ 次多项式</p>
<p>$$
\begin{aligned}
f(x) = \sum_{i=0}^n f_ix^i &amp;=  f_0 + f_1 x + f_2x^2 + \cdots + g_nx^n \\
g(x) = \sum_{i=0}^n g_ix^i &amp;=  g_0 + g_1 x + g_2x^2 + \cdots + g_nx^n
\end{aligned}
$$</p>
<p>它们的卷积是 $F(x) = f(x) \ast g(x) = (f \ast g)(x) = \sum\limits_{k=0}^{2n} c_kx^k$，其中</p>
<p>$$
c_k = \sum_{i+j=k}f_ig_j
$$</p>
<p>因此朴素的计算多项式的卷积需要 $n^2$ 次系数乘法，我们需要优化。</p>
<h3 id="点值表示法">点值表示法<a hidden class="anchor" aria-hidden="true" href="#点值表示法">#</a></h3>
<p>$n$ 次多项式 $f(x)$ 可以由 $n+1$ 个系数决定，也可以由 $n+1$ 个座标（点值）决定。即 $n$ 次多项式可以看作 $n+1$ 维的向量。</p>
<p>考虑选取 $2n+1$ 个座标来确定 $f(x)$ 和 $g(x)$。则 $F(x)$ 可以简单的通过做 $2n+1$ 次乘法得到</p>
<p>$$
(x_k,F(x_k)) = \left(x_k, f(x_k)g(x_k)\right)
$$</p>
<p>现在我们有了新的思路：先从系数表示法转换为点值表示法，做完乘法后再变回去。</p>
<h3 id="dft">DFT<a hidden class="anchor" aria-hidden="true" href="#dft">#</a></h3>
<p>怎么把多项式转换成点值呢？我们有离散 Fourier 变换。</p>
<p>称方程 $x^n = 1$ 的 $n$ 个解为单位根 $\zeta_n$。对于给定的多项式 $f(x) = \sum\limits_{k=0}^{n-1} f_kx^k$ 和一个单位根 $\zeta_n$，称向量</p>
<p>$$
\operatorname{DFT}_{\zeta_n}(f) =( f(1), f(\zeta_n^1), \cdots, f(\zeta_n^{n-1}) )
$$</p>
<p>为 $f$ 的离散 Fourier 变换（Discrete Fourier Transform）。</p>
<p>DFT 存在逆变换（IDFT），即从点值重新变回系数，仍是从向量到向量的变换。</p>
<p>IDFT 具有一个关键性质</p>
<p>$$
(\operatorname{DFT}_{\zeta})^{-1} = \frac{1}{n} (\operatorname{DFT}_{{\zeta}^{-1}}) \tag{1}
$$</p>
<p>我们将在后文证明它。现在我们可以统一的处理 DFT 和 IDFT。</p>
<p>为了方便描述，接下来我们将把 $\operatorname{DFT}_{\zeta_n}$ 简单的记作 $\mathcal{F}_n$。</p>
<h3 id="单位原根">单位原根<a hidden class="anchor" aria-hidden="true" href="#单位原根">#</a></h3>
<p>至此，我们计算 DFT 的复杂度仍然是 $O(n^2)$，FFT 所迈出的关键一步是选取特殊的点加速计算。</p>
<p>单位根中特殊的一个记作 $\zeta_n = e^{\frac{2 \pi i}{n}}$，它叫做单位原根。依 Euler 公式，有</p>
<p>$$
\zeta_n = e^{\tfrac{2 \pi i}{n}} = \cos \left(\frac{2\pi}{n}\right) + i \sin \left(\frac{2\pi}{n}\right)
$$</p>
<p>即 $\zeta_n$ 是单位圆上的一个点，全部的 $n$ 个单位根</p>
<p>$$
x_k = \zeta_n^k = e^{k\tfrac{2 \pi i}{n}} = \cos \left(\frac{2\pi k}{n}\right) + i \sin \left(\frac{2\pi k}{n}\right)
$$</p>
<p>恰对应到单位圆的 $n$ 等分点。因此根据 Euler 公式，<strong>单位根之间的乘法就是在单位圆上转圈圈。</strong></p>
<p>不难通过 Euler 公式验证单位原根 $\zeta_n$ 的几条性质：</p>
<ul>
<li>$\zeta_{2n}^{2k} = \zeta_n^k$。</li>
<li>$\zeta_{2n}^{n+k} = -\zeta_{2n}^k$。</li>
</ul>
<h3 id="分治">分治<a hidden class="anchor" aria-hidden="true" href="#分治">#</a></h3>
<p>利用单位原根的特殊性，我们可以分治计算 DFT。比如对于 $7$ 次多项式</p>
<p>$$
\begin{aligned}
f(x) &amp;= f_0 + f_1x + f_2x^2 + f_3 x^3 + f_4 x^4 + f_5 x^5 + f_6 x^6 + f_7 x^7 \\
&amp;= (f_0 + f_2x^2 + f_4x^4 + f_6x^6) + x(f_1 + f_3x^2 + f_5x^4 + f_7x^6)
\end{aligned}
$$</p>
<p>奇偶分类</p>
<p>$$
\begin{aligned}
f^{[0]}(x) &amp;= f_0 + f_2x + f_4x^2 + f_6x^3 \\
f^{[1]}(x) &amp;= f_1 + f_3x + f_5x^2 + f_7x^3
\end{aligned}
$$</p>
<p>则原来的函数可以表示为</p>
<p>$$
f(x) = f^{[0]}(x^2) + xf^{[1]}(x^2)
$$</p>
<p>一般的，对于度小于 $n$ 的多项式 $f(x)$，在单位根 $x = \zeta_n^k$ 处的点值是</p>
<p>$$
\begin{aligned}
f(\zeta_n^k) &amp;= f^{[0]}(\zeta_n^k \cdot \zeta_n^k) + \zeta_n^kf^{[1]}(\zeta_n^k \cdot \zeta_n^k) \\
&amp;= f^{[0]}(\zeta_n^{2k}) + \zeta_n^kf^{[1]}(\zeta_n^{2k}) \\
&amp;= f^{[0]}(\zeta_{n/2}^{k}) + \zeta_n^kf^{[1]}(\zeta_{n/2}^{k})
\end{aligned}
$$</p>
<p>同理可得</p>
<p>$$
\begin{aligned}
f(\zeta_n^{k+n/2}) &amp;= f^{[0]}(\zeta_n^{2k+n}) + \zeta_n^{k+n/2}f^{[1]}(\zeta_n^{2k+n}) \\
&amp;= f^{[0]}(\zeta_{n/2}^{k}) - \zeta_n^{k}f^{[1]}(\zeta_{n/2}^{k})
\end{aligned}
$$</p>
<p>在 DFT 中使用有</p>
<p>$$
\begin{aligned}
\mathcal{F}_n(f)[j] &amp;= \mathcal{F}_{n/2}(f^{[0]})[j] + \zeta_n^j \mathcal{F}_{n/2}(f^{[1]})[j] \\
\mathcal{F}_n(f)[j + n/2] &amp;= \mathcal{F}_{n/2}(f^{[0]})[j] - \zeta_n^j\mathcal{F}_{n/2}(f^{[1]})[j]
\end{aligned}
\tag{2}
$$</p>
<p>因此我们需要把多项式的系数个数向上补到 $2^n$，方便分治。</p>
<p>至此，我们可以写出递归版的 FFT。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-cpp" data-lang="cpp"><span class="kt">void</span> <span class="nf">fft</span><span class="p">(</span><span class="kt">int</span> <span class="n">n</span><span class="p">,</span> <span class="n">img</span> <span class="o">*</span><span class="n">f</span><span class="p">,</span> <span class="kt">int</span> <span class="n">op</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">static</span> <span class="n">img</span> <span class="n">tmp</span><span class="p">[</span><span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="mi">18</span><span class="p">];</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">n</span> <span class="o">==</span> <span class="mi">1</span><span class="p">)</span>
        <span class="k">return</span><span class="p">;</span>
    <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">n</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
        <span class="n">tmp</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">f</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>
    <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">n</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>  <span class="c1">// 偶数放左边，奇数放右边
</span><span class="c1"></span>        <span class="k">if</span> <span class="p">(</span><span class="n">i</span> <span class="o">&amp;</span> <span class="mi">1</span><span class="p">)</span>
            <span class="n">f</span><span class="p">[</span><span class="n">n</span> <span class="o">/</span> <span class="mi">2</span> <span class="o">+</span> <span class="n">i</span> <span class="o">/</span> <span class="mi">2</span><span class="p">]</span> <span class="o">=</span> <span class="n">tmp</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>
        <span class="k">else</span>
            <span class="n">f</span><span class="p">[</span><span class="n">i</span> <span class="o">/</span> <span class="mi">2</span><span class="p">]</span> <span class="o">=</span> <span class="n">tmp</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>
    <span class="p">}</span>
    <span class="n">img</span> <span class="o">*</span><span class="n">g</span> <span class="o">=</span> <span class="n">f</span><span class="p">,</span> <span class="o">*</span><span class="n">h</span> <span class="o">=</span> <span class="n">f</span> <span class="o">+</span> <span class="n">n</span> <span class="o">/</span> <span class="mi">2</span><span class="p">;</span>
    <span class="n">fft</span><span class="p">(</span><span class="n">n</span> <span class="o">/</span> <span class="mi">2</span><span class="p">,</span> <span class="n">g</span><span class="p">,</span> <span class="n">op</span><span class="p">),</span> <span class="n">fft</span><span class="p">(</span><span class="n">n</span> <span class="o">/</span> <span class="mi">2</span><span class="p">,</span> <span class="n">h</span><span class="p">,</span> <span class="n">op</span><span class="p">);</span>
    <span class="n">img</span> <span class="n">w0</span> <span class="o">=</span> <span class="p">{</span><span class="n">cos</span><span class="p">(</span><span class="mi">2</span> <span class="o">*</span> <span class="n">PI</span> <span class="o">/</span> <span class="n">n</span><span class="p">),</span> <span class="n">sin</span><span class="p">(</span><span class="mi">2</span> <span class="o">*</span> <span class="n">PI</span> <span class="o">*</span> <span class="n">op</span> <span class="o">/</span> <span class="n">n</span><span class="p">)},</span> <span class="n">w</span> <span class="o">=</span> <span class="p">{</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">};</span>
    <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">k</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">k</span> <span class="o">&lt;</span> <span class="n">n</span> <span class="o">/</span> <span class="mi">2</span><span class="p">;</span> <span class="n">k</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">tmp</span><span class="p">[</span><span class="n">k</span><span class="p">]</span> <span class="o">=</span> <span class="n">g</span><span class="p">[</span><span class="n">k</span><span class="p">]</span> <span class="o">+</span> <span class="n">w</span> <span class="o">*</span> <span class="n">h</span><span class="p">[</span><span class="n">k</span><span class="p">];</span>
        <span class="n">tmp</span><span class="p">[</span><span class="n">k</span> <span class="o">+</span> <span class="n">n</span> <span class="o">/</span> <span class="mi">2</span><span class="p">]</span> <span class="o">=</span> <span class="n">g</span><span class="p">[</span><span class="n">k</span><span class="p">]</span> <span class="o">-</span> <span class="n">w</span> <span class="o">*</span> <span class="n">h</span><span class="p">[</span><span class="n">k</span><span class="p">];</span>
        <span class="n">w</span> <span class="o">=</span> <span class="n">w</span> <span class="o">*</span> <span class="n">w0</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">n</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
        <span class="n">f</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">tmp</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>
<span class="p">}</span>
</code></pre></div><h3 id="蝴蝶变换">蝴蝶变换<a hidden class="anchor" aria-hidden="true" href="#蝴蝶变换">#</a></h3>
<p>递归分治总是不尽人意的，我们在前几行只是做了递归分组的事情，可以考虑一步到位。</p>
<p>还是以 $7$ 次多项式为例</p>
<ul>
<li>初始 $\{x^0,x^1,x^2,x^3,x^4,x^5,x^6,x^7\}$</li>
<li>一次 $\{x^0,x^2,x^4,x^6\},\{x^1,x^3,x^5,x^7\}$</li>
<li>两次 $\{x^0,x^4\},\{x^2,x^6\},\{x^1,x^5\},\{x^3,x^7\}$</li>
<li>结束 $\{x^0\},\{x^4\},\{x^2\},\{x^6\},\{x^1\},\{x^5\},\{x^3\},\{x^7\}$</li>
</ul>
<p>写出二进制的形式，可以发现：结束和开始的二进制恰好是相反的。</p>
<table>
<thead>
<tr>
<th style="text-align:center">初始</th>
<th style="text-align:center">0</th>
<th style="text-align:center">1</th>
<th style="text-align:center">2</th>
<th style="text-align:center">3</th>
<th style="text-align:center">4</th>
<th style="text-align:center">5</th>
<th style="text-align:center">6</th>
<th style="text-align:center">7</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">初始(2)</td>
<td style="text-align:center">000</td>
<td style="text-align:center">001</td>
<td style="text-align:center">010</td>
<td style="text-align:center">011</td>
<td style="text-align:center">100</td>
<td style="text-align:center">101</td>
<td style="text-align:center">110</td>
<td style="text-align:center">111</td>
</tr>
<tr>
<td style="text-align:center">结束(2)</td>
<td style="text-align:center">000</td>
<td style="text-align:center">100</td>
<td style="text-align:center">010</td>
<td style="text-align:center">110</td>
<td style="text-align:center">001</td>
<td style="text-align:center">101</td>
<td style="text-align:center">011</td>
<td style="text-align:center">111</td>
</tr>
<tr>
<td style="text-align:center">结束</td>
<td style="text-align:center">0</td>
<td style="text-align:center">4</td>
<td style="text-align:center">2</td>
<td style="text-align:center">6</td>
<td style="text-align:center">1</td>
<td style="text-align:center">5</td>
<td style="text-align:center">3</td>
<td style="text-align:center">7</td>
</tr>
</tbody>
</table>
<p>这个变换称为蝴蝶变换，也称位逆序置换（bit-reversal permutation）。</p>
<p>我们可以 $O(n)$ 的预处理出变换数组。设 <code>R(x)</code> 是 $x$ 的变换结果，则 <code>R(x &gt;&gt; 1)</code> 此时是已知的。即是把 <code>R(x &gt;&gt; 1)</code> 右移一位再补上最高位即可。代码如下</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-cpp" data-lang="cpp"><span class="kt">void</span> <span class="nf">pre_rev</span><span class="p">(</span><span class="kt">int</span> <span class="n">lim</span><span class="p">)</span> <span class="p">{</span>
    <span class="kt">int</span> <span class="n">k</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="n">__lg</span><span class="p">(</span><span class="n">lim</span><span class="p">);</span>
    <span class="n">rev</span><span class="p">.</span><span class="n">resize</span><span class="p">(</span><span class="n">lim</span><span class="p">);</span>
    <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">lim</span><span class="p">;</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">rev</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">rev</span><span class="p">[</span><span class="n">i</span> <span class="o">&gt;&gt;</span> <span class="mi">1</span><span class="p">]</span> <span class="o">&gt;&gt;</span> <span class="mi">1</span><span class="p">;</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">i</span> <span class="o">&amp;</span> <span class="mi">1</span><span class="p">)</span>
            <span class="n">rev</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">|=</span> <span class="n">lim</span> <span class="o">&gt;&gt;</span> <span class="mi">1</span><span class="p">;</span>
        <span class="c1">// 或者合并写为
</span><span class="c1"></span>        <span class="c1">// rev[i] = (rev[i &gt;&gt; 1] &gt;&gt; 1) | ((i &amp; 1) &lt;&lt; (k - 1));
</span><span class="c1"></span>    <span class="p">}</span>
<span class="p">}</span>
</code></pre></div><p>现在我们可以写出非递归版的 FFT。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-cpp" data-lang="cpp"><span class="kt">void</span> <span class="nf">fft</span><span class="p">(</span><span class="n">img</span> <span class="o">*</span><span class="n">f</span><span class="p">,</span> <span class="kt">int</span> <span class="n">n</span><span class="p">,</span> <span class="kt">int</span> <span class="n">op</span><span class="p">)</span> <span class="p">{</span> <span class="c1">// DIT
</span><span class="c1"></span>    <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">n</span><span class="p">;</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">i</span> <span class="o">&lt;</span> <span class="n">rev</span><span class="p">[</span><span class="n">i</span><span class="p">])</span>
            <span class="n">swap</span><span class="p">(</span><span class="n">f</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">f</span><span class="p">[</span><span class="n">rev</span><span class="p">[</span><span class="n">i</span><span class="p">]]);</span>
    <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">l</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span> <span class="n">l</span> <span class="o">&lt;=</span> <span class="n">n</span> <span class="o">/</span> <span class="mi">2</span><span class="p">;</span> <span class="n">l</span> <span class="o">&lt;&lt;=</span> <span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">img</span> <span class="n">w0</span> <span class="o">=</span> <span class="p">{</span><span class="n">cos</span><span class="p">(</span><span class="n">PI</span> <span class="o">/</span> <span class="n">l</span><span class="p">),</span> <span class="n">sin</span><span class="p">(</span><span class="n">PI</span> <span class="o">*</span> <span class="n">op</span> <span class="o">/</span> <span class="n">l</span><span class="p">)};</span>
        <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">n</span><span class="p">;</span> <span class="n">i</span> <span class="o">+=</span> <span class="n">l</span> <span class="o">*</span> <span class="mi">2</span><span class="p">)</span> <span class="p">{</span>
            <span class="n">img</span> <span class="n">w</span> <span class="o">=</span> <span class="p">{</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">};</span>
            <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">j</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">j</span> <span class="o">&lt;</span> <span class="n">l</span><span class="p">;</span> <span class="n">j</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
                <span class="n">img</span> <span class="n">x</span> <span class="o">=</span> <span class="n">f</span><span class="p">[</span><span class="n">i</span> <span class="o">+</span> <span class="n">j</span><span class="p">],</span> <span class="n">y</span> <span class="o">=</span> <span class="n">w</span> <span class="o">*</span> <span class="n">f</span><span class="p">[</span><span class="n">i</span> <span class="o">+</span> <span class="n">j</span> <span class="o">+</span> <span class="n">l</span><span class="p">];</span>
                <span class="n">f</span><span class="p">[</span><span class="n">i</span> <span class="o">+</span> <span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="n">x</span> <span class="o">+</span> <span class="n">y</span><span class="p">,</span> <span class="n">f</span><span class="p">[</span><span class="n">i</span> <span class="o">+</span> <span class="n">j</span> <span class="o">+</span> <span class="n">l</span><span class="p">]</span> <span class="o">=</span> <span class="n">x</span> <span class="o">-</span> <span class="n">y</span><span class="p">;</span>
                <span class="n">w</span> <span class="o">=</span> <span class="n">w</span> <span class="o">*</span> <span class="n">w0</span><span class="p">;</span>
            <span class="p">}</span>
        <span class="p">}</span>
    <span class="p">}</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">op</span> <span class="o">==</span> <span class="o">-</span><span class="mi">1</span><span class="p">)</span>
        <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">n</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
            <span class="n">f</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">f</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">/</span> <span class="n">n</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div><h2 id="ntt">NTT<a hidden class="anchor" aria-hidden="true" href="#ntt">#</a></h2>
<p>前置知识：数论基础（整除，同余）。</p>
<p>用 <code>double</code> 去实现整数的乘法是很不优美的，精度、速度都很成问题。实际上，我们可以仅在整数下进行运算。</p>
<h3 id="原根">原根<a hidden class="anchor" aria-hidden="true" href="#原根">#</a></h3>
<p>我们本质上用到的单位原根 $\zeta_n$ 的两个性质是：</p>
<ul>
<li>$\zeta_{n}^{n} = 1$。</li>
<li>$\zeta_{2n}^{n} = -1$。</li>
</ul>
<p>可以联想到模 $p$ 剩余类域 $\mathbb{Z}_p$：其中的元素是 $\{0,1,\cdots,p-1\}$，其上的运算都是模 $p$ 的。由于 Fermat 小定理</p>
<p>$$
a^{\varphi(p)} = a^{p-1} \equiv 1
$$</p>
<p>即从另一个角度说，$p-1$ 个正整数都是同余方程 $x^{p-1} \equiv 1$ 的解。</p>
<p>它和单位根有很相似的形式，直觉上 $\mathbb{Z}_p$ 也存在类似单位原根的特殊数字。下面我们在 $\mathbb{Z}_p$ 上讨论，尝试证明这个数字存在。</p>
<p>定义正整数 $a \in \mathbb{Z}_p$ 的阶 $\delta_p(a)$ 为最小的 $r$ 使得 $a^r \equiv 1$。由 Fermat 小定理 $a^{\varphi(p)} \equiv 1$，因此 $a$ 的阶一定存在且有 $\delta_p(a) \mid \varphi(p)$。可以证明</p>
<p>$$
a,a^2,\cdots a^{\delta_p(a)} \tag{3}
$$</p>
<p>在模 $p$ 下余数互不相同。由 Lagrange 定理，$x^{\delta_p(a)} \equiv 1$ 的解至多有 $\delta_p(a)$ 个，恰是 $(3)$ 中所展示的。</p>
<p>通过整除的性质，可以想到只有 $i \bot \delta_p(a)$ 才有 $\delta_p(a^i) = \delta_p(a)$，即 $a$ 总是附带着</p>
<p>$$
\sum_{i=1}^{\delta_p(a)} [\gcd(i, \delta_p(a)) = 1] = \varphi(\delta_p(a))
$$</p>
<p>个阶相同的东西。因此阶为 $\delta_p(a)$ 的数恰有 $\varphi(\delta_p(a))$ 个。</p>
<p>因为每个正整数都有唯一确定的阶，不妨假设对于所有 $d \mid \varphi(p)$，阶 $d$ 都存在 $\varphi(d)$ 个对应的整数，统计整数个数</p>
<p>$$
\sum_{d \mid \varphi(p)} \varphi(d) = \varphi(p) = p - 1
$$</p>
<p>恰为 $\mathbb{Z}_p$ 全部正整数的个数，因此假设成立，也就存在 $a$ 使得 $\delta_p(a) = p-1$。</p>
<p>我们称这个 $a$ 是模 $p$ 下的一个原根，常用字母 $g$ 表示。</p>
<h3 id="快速数论变换">快速数论变换<a hidden class="anchor" aria-hidden="true" href="#快速数论变换">#</a></h3>
<p>尽可能提取 $p - 1$ 的因子 $2$ 有</p>
<p>$$
p = N q + 1, N = 2^m
$$</p>
<p>设 $\mathbb{Z}_p$ 的一个原根 $g$，将 $g_N \equiv g^q$ 看作 $\zeta_n$ 的等价。利用二次剩余的知识不难得到 $g_N^N \equiv 1$ 和 $g_N^{N/2} \equiv -1$。</p>
<p>常见的有</p>
<p>$$
\begin{aligned}
p = 1004535809 = 479 \times 2^{21} + 1&amp;, g = 3 \\
p = 998244353 = 7 \times 17 \times 2^{23} + 1&amp;, g = 3
\end{aligned}
$$</p>
<p>类似的，我们可以写出程序</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-cpp" data-lang="cpp"><span class="kt">void</span> <span class="nf">ntt</span><span class="p">(</span><span class="n">ll</span> <span class="o">*</span><span class="n">f</span><span class="p">,</span> <span class="kt">int</span> <span class="n">n</span><span class="p">,</span> <span class="kt">int</span> <span class="n">type</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">n</span><span class="p">;</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">i</span> <span class="o">&lt;</span> <span class="n">rev</span><span class="p">[</span><span class="n">i</span><span class="p">])</span>
            <span class="n">swap</span><span class="p">(</span><span class="n">f</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">f</span><span class="p">[</span><span class="n">rev</span><span class="p">[</span><span class="n">i</span><span class="p">]]);</span>
    <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">h</span> <span class="o">=</span> <span class="mi">2</span><span class="p">;</span> <span class="n">h</span> <span class="o">&lt;</span> <span class="n">n</span><span class="p">;</span> <span class="n">h</span> <span class="o">&lt;&lt;=</span> <span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">ll</span> <span class="n">tg</span> <span class="o">=</span> <span class="n">type</span> <span class="o">==</span> <span class="mi">1</span> <span class="o">?</span> <span class="mi">3</span> <span class="o">:</span> <span class="n">g_inv</span><span class="p">;</span>
        <span class="n">ll</span> <span class="n">gn</span> <span class="o">=</span> <span class="n">qpow</span><span class="p">(</span><span class="n">tg</span><span class="p">,</span> <span class="p">(</span><span class="n">P</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="o">/</span> <span class="n">h</span><span class="p">);</span>
        <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">j</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">j</span> <span class="o">&lt;</span> <span class="n">n</span><span class="p">;</span> <span class="n">j</span> <span class="o">+=</span> <span class="n">h</span><span class="p">)</span> <span class="p">{</span>
            <span class="n">ll</span> <span class="n">g</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
            <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">k</span> <span class="o">=</span> <span class="n">j</span><span class="p">;</span> <span class="n">k</span> <span class="o">&lt;</span> <span class="n">j</span> <span class="o">+</span> <span class="n">h</span> <span class="o">/</span> <span class="mi">2</span><span class="p">;</span> <span class="n">k</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
                <span class="n">ll</span> <span class="n">f1</span> <span class="o">=</span> <span class="n">f</span><span class="p">[</span><span class="n">k</span><span class="p">],</span> <span class="n">f2</span> <span class="o">=</span> <span class="n">g</span> <span class="o">*</span> <span class="n">f</span><span class="p">[</span><span class="n">k</span> <span class="o">+</span> <span class="n">h</span> <span class="o">/</span> <span class="mi">2</span><span class="p">]</span> <span class="o">%</span> <span class="n">P</span><span class="p">;</span>
                <span class="n">f</span><span class="p">[</span><span class="n">k</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="n">f1</span> <span class="o">+</span> <span class="n">f2</span><span class="p">)</span> <span class="o">%</span> <span class="n">P</span><span class="p">;</span>
                <span class="n">f</span><span class="p">[</span><span class="n">k</span> <span class="o">+</span> <span class="n">h</span> <span class="o">/</span> <span class="mi">2</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="n">f1</span> <span class="o">-</span> <span class="n">f2</span> <span class="o">+</span> <span class="n">P</span><span class="p">)</span> <span class="o">%</span> <span class="n">P</span><span class="p">;</span>
                <span class="n">g</span> <span class="o">=</span> <span class="n">g</span> <span class="o">*</span> <span class="n">gn</span> <span class="o">%</span> <span class="n">P</span><span class="p">;</span>
            <span class="p">}</span>
        <span class="p">}</span>
    <span class="p">}</span>
    <span class="n">ll</span> <span class="n">iv_n</span> <span class="o">=</span> <span class="n">qpow</span><span class="p">(</span><span class="n">n</span><span class="p">);</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">type</span> <span class="o">==</span> <span class="o">-</span><span class="mi">1</span><span class="p">)</span>
        <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">n</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
            <span class="n">f</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">f</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">*</span> <span class="n">iv_n</span> <span class="o">%</span> <span class="n">P</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div><p>至此，你已经学会 FFT 了。下面我们将更深入的从数学角度研究 FFT，补足理论基础。</p>
<h2 id="线性变换">线性变换<a hidden class="anchor" aria-hidden="true" href="#线性变换">#</a></h2>
<p>DFT 是一个线性变换。换句话说，它可以被写成矩阵乘法的形式</p>
<p>$$
\begin{bmatrix}
f(\zeta_n^0) \\ f(\zeta_n^1) \\ f(\zeta_n^2) \\ \vdots \\ f(\zeta_n^{n-1})
\end{bmatrix} = \begin{bmatrix}
1 &amp; 1 &amp; 1 &amp; \cdots &amp; 1 \\
1 &amp; \zeta_n^1 &amp; \zeta_n^2 &amp; \cdots &amp; \zeta_n^{n-1} \\
1 &amp; \zeta_n^2 &amp; \zeta_n^4 &amp; \cdots &amp; \zeta_n^{2(n-1)} \\
\vdots &amp; \vdots &amp; \vdots  &amp; \ddots &amp; \vdots \\
1 &amp; \zeta_n^{n-1} &amp; \zeta_n^{2(n-1)} &amp; \cdots &amp; \zeta_n^{(n-1)^2}
\end{bmatrix}
\begin{bmatrix}
f_0 \\ f_1 \\ f_2 \\ \vdots \\ f_{n-1}
\end{bmatrix}
$$</p>
<p>我们把中间的那个 $n$ 阶的 Vandermonde 方阵记为 $V(\zeta_n) = (\zeta_n^{ij})$。</p>
<p>直接计算 $V(\zeta_n)$ 的逆很不好算，但是验证下式是对角矩阵还是容易的</p>
<p>$$
V(\zeta_n) V(\zeta_n^{-1}) = (n[i = j]) = n I_n
$$</p>
<p>即 IDFT 所对应的矩阵为 $V^{-1}(\zeta_n) = \frac{1}{n} V(\zeta_n^{-1})$，我们便证明了 $(1)$ 式。</p>
<h3 id="干掉-rev">干掉 REV<a hidden class="anchor" aria-hidden="true" href="#干掉-rev">#</a></h3>
<p>其实上文所实现的 FFT 和 IFFT 并不对偶，只是卷积定理使得 IFFT 恰是 FFT 的逆运算。具体的说，我们实现了两个 DIT，因此需要在计算之前进行蝴蝶变换。</p>
<p><img loading="lazy" src="https://upload.wikimedia.org/wikipedia/commons/f/f2/DIF_DIT.jpg" alt="Wikipedia"  />
</p>
<p>我们运算的核心内容在于 $(2)$ 式，它可以被写做矩阵形式。</p>
<p>$$
\begin{bmatrix}
O_1 \\ O_2
\end{bmatrix} =
\begin{bmatrix}
1 &amp; \zeta_n^{-j} \\
1 &amp; -\zeta_n^{-j}
\end{bmatrix}
\begin{bmatrix}
I_1 \\ I_2
\end{bmatrix}
$$</p>
<p>对矩阵求逆</p>
<p>$$
\begin{bmatrix}
I_1 \\ I_2
\end{bmatrix} = \frac{1}{2}
\begin{bmatrix}
1 &amp; 1 \\
\zeta_n^{j} &amp; -\zeta_n^{j}
\end{bmatrix}
\begin{bmatrix}
O_1 \\ O_2
\end{bmatrix} \tag{4}
$$</p>
<p>我们便得到了 DIF。类似的，我们可以实现两个 DIF 作为 FFT，此时蝴蝶变换在计算之后。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-cpp" data-lang="cpp"><span class="kt">void</span> <span class="nf">fft</span><span class="p">(</span><span class="n">img</span> <span class="o">*</span><span class="n">f</span><span class="p">,</span> <span class="kt">int</span> <span class="n">n</span><span class="p">,</span> <span class="kt">int</span> <span class="n">op</span><span class="p">)</span> <span class="p">{</span> <span class="c1">// DIF
</span><span class="c1"></span>    <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">l</span> <span class="o">=</span> <span class="n">n</span> <span class="o">/</span> <span class="mi">2</span><span class="p">;</span> <span class="n">l</span> <span class="o">&gt;=</span> <span class="mi">1</span><span class="p">;</span> <span class="n">l</span> <span class="o">&gt;&gt;=</span> <span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">img</span> <span class="n">w0</span> <span class="o">=</span> <span class="p">{</span><span class="n">cos</span><span class="p">(</span><span class="n">PI</span> <span class="o">/</span> <span class="n">l</span><span class="p">),</span> <span class="n">sin</span><span class="p">(</span><span class="n">PI</span> <span class="o">*</span> <span class="n">op</span> <span class="o">/</span> <span class="n">l</span><span class="p">)};</span>
        <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">n</span><span class="p">;</span> <span class="n">i</span> <span class="o">+=</span> <span class="n">l</span> <span class="o">*</span> <span class="mi">2</span><span class="p">)</span> <span class="p">{</span>
            <span class="n">img</span> <span class="n">w</span> <span class="o">=</span> <span class="p">{</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">};</span>
            <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">j</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">j</span> <span class="o">&lt;</span> <span class="n">l</span><span class="p">;</span> <span class="n">j</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
                <span class="n">img</span> <span class="n">x</span> <span class="o">=</span> <span class="n">f</span><span class="p">[</span><span class="n">i</span> <span class="o">+</span> <span class="n">j</span><span class="p">],</span> <span class="n">y</span> <span class="o">=</span> <span class="n">f</span><span class="p">[</span><span class="n">i</span> <span class="o">+</span> <span class="n">j</span> <span class="o">+</span> <span class="n">l</span><span class="p">];</span>
                <span class="n">f</span><span class="p">[</span><span class="n">i</span> <span class="o">+</span> <span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="n">x</span> <span class="o">+</span> <span class="n">y</span><span class="p">,</span> <span class="n">f</span><span class="p">[</span><span class="n">i</span> <span class="o">+</span> <span class="n">j</span> <span class="o">+</span> <span class="n">l</span><span class="p">]</span> <span class="o">=</span> <span class="n">w</span> <span class="o">*</span> <span class="p">(</span><span class="n">x</span> <span class="o">-</span> <span class="n">y</span><span class="p">);</span>
                <span class="n">w</span> <span class="o">=</span> <span class="n">w</span> <span class="o">*</span> <span class="n">w0</span><span class="p">;</span>
            <span class="p">}</span>
        <span class="p">}</span>
    <span class="p">}</span>
    <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">n</span><span class="p">;</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">i</span> <span class="o">&lt;</span> <span class="n">rev</span><span class="p">[</span><span class="n">i</span><span class="p">])</span>
            <span class="n">swap</span><span class="p">(</span><span class="n">f</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">f</span><span class="p">[</span><span class="n">rev</span><span class="p">[</span><span class="n">i</span><span class="p">]]);</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">op</span> <span class="o">==</span> <span class="o">-</span><span class="mi">1</span><span class="p">)</span>
        <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">n</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
            <span class="n">f</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">f</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">/</span> <span class="n">n</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div><p>容易发现，若我们以 DIF 作为 FFT，DIT 作为 IFFT，是不需要蝴蝶变换的。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-cpp" data-lang="cpp"><span class="kt">void</span> <span class="nf">fft</span><span class="p">(</span><span class="n">img</span> <span class="o">*</span><span class="n">f</span><span class="p">,</span> <span class="kt">int</span> <span class="n">n</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">l</span> <span class="o">=</span> <span class="n">n</span> <span class="o">/</span> <span class="mi">2</span><span class="p">;</span> <span class="n">l</span> <span class="o">&gt;=</span> <span class="mi">1</span><span class="p">;</span> <span class="n">l</span> <span class="o">&gt;&gt;=</span> <span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">img</span> <span class="n">w0</span> <span class="o">=</span> <span class="p">{</span><span class="n">cos</span><span class="p">(</span><span class="n">PI</span> <span class="o">/</span> <span class="n">l</span><span class="p">),</span> <span class="n">sin</span><span class="p">(</span><span class="n">PI</span> <span class="o">/</span> <span class="n">l</span><span class="p">)};</span>
        <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">n</span><span class="p">;</span> <span class="n">i</span> <span class="o">+=</span> <span class="n">l</span> <span class="o">*</span> <span class="mi">2</span><span class="p">)</span> <span class="p">{</span>
            <span class="n">img</span> <span class="n">w</span> <span class="o">=</span> <span class="p">{</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">};</span>
            <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">j</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">j</span> <span class="o">&lt;</span> <span class="n">l</span><span class="p">;</span> <span class="n">j</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
                <span class="n">img</span> <span class="n">x</span> <span class="o">=</span> <span class="n">f</span><span class="p">[</span><span class="n">i</span> <span class="o">+</span> <span class="n">j</span><span class="p">],</span> <span class="n">y</span> <span class="o">=</span> <span class="n">f</span><span class="p">[</span><span class="n">i</span> <span class="o">+</span> <span class="n">j</span> <span class="o">+</span> <span class="n">l</span><span class="p">];</span>
                <span class="n">f</span><span class="p">[</span><span class="n">i</span> <span class="o">+</span> <span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="n">x</span> <span class="o">+</span> <span class="n">y</span><span class="p">,</span> <span class="n">f</span><span class="p">[</span><span class="n">i</span> <span class="o">+</span> <span class="n">j</span> <span class="o">+</span> <span class="n">l</span><span class="p">]</span> <span class="o">=</span> <span class="n">w</span> <span class="o">*</span> <span class="p">(</span><span class="n">x</span> <span class="o">-</span> <span class="n">y</span><span class="p">);</span>
                <span class="n">w</span> <span class="o">=</span> <span class="n">w</span> <span class="o">*</span> <span class="n">w0</span><span class="p">;</span>
            <span class="p">}</span>
        <span class="p">}</span>
    <span class="p">}</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="nf">ifft</span><span class="p">(</span><span class="n">img</span> <span class="o">*</span><span class="n">f</span><span class="p">,</span> <span class="kt">int</span> <span class="n">n</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">l</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span> <span class="n">l</span> <span class="o">&lt;=</span> <span class="n">n</span> <span class="o">/</span> <span class="mi">2</span><span class="p">;</span> <span class="n">l</span> <span class="o">&lt;&lt;=</span> <span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">img</span> <span class="n">w0</span> <span class="o">=</span> <span class="n">img</span><span class="p">{</span><span class="n">cos</span><span class="p">(</span><span class="n">PI</span> <span class="o">/</span> <span class="n">l</span><span class="p">),</span> <span class="n">sin</span><span class="p">(</span><span class="n">PI</span> <span class="o">/</span> <span class="n">l</span><span class="p">)}.</span><span class="n">conj</span><span class="p">();</span>
        <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">n</span><span class="p">;</span> <span class="n">i</span> <span class="o">+=</span> <span class="n">l</span> <span class="o">*</span> <span class="mi">2</span><span class="p">)</span> <span class="p">{</span>
            <span class="n">img</span> <span class="n">w</span> <span class="o">=</span> <span class="p">{</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">};</span>
            <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">j</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">j</span> <span class="o">&lt;</span> <span class="n">l</span><span class="p">;</span> <span class="n">j</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
                <span class="n">img</span> <span class="n">x</span> <span class="o">=</span> <span class="n">f</span><span class="p">[</span><span class="n">i</span> <span class="o">+</span> <span class="n">j</span><span class="p">],</span> <span class="n">y</span> <span class="o">=</span> <span class="n">w</span> <span class="o">*</span> <span class="n">f</span><span class="p">[</span><span class="n">i</span> <span class="o">+</span> <span class="n">j</span> <span class="o">+</span> <span class="n">l</span><span class="p">];</span>
                <span class="n">f</span><span class="p">[</span><span class="n">i</span> <span class="o">+</span> <span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="n">x</span> <span class="o">+</span> <span class="n">y</span><span class="p">,</span> <span class="n">f</span><span class="p">[</span><span class="n">i</span> <span class="o">+</span> <span class="n">j</span> <span class="o">+</span> <span class="n">l</span><span class="p">]</span> <span class="o">=</span> <span class="n">x</span> <span class="o">-</span> <span class="n">y</span><span class="p">;</span>
                <span class="n">w</span> <span class="o">=</span> <span class="n">w</span> <span class="o">*</span> <span class="n">w0</span><span class="p">;</span>
            <span class="p">}</span>
        <span class="p">}</span>
    <span class="p">}</span>
    <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">n</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
        <span class="n">f</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">f</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">/</span> <span class="n">n</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div><p>以上，便是 Twisted FFT。</p>
<h3 id="另一种理解">另一种理解<a hidden class="anchor" aria-hidden="true" href="#另一种理解">#</a></h3>
<p>注意到</p>
<p>$$
f(x_0) = f \bmod (x - x_0)
$$</p>
<p>我们可以从这方面着手，从取模角度重新审视上述算法。假设 $f$ 可以被分解为</p>
<p>$$
f = (x^n - r)(x^n + r)f_{0} + (x^n - r)f_{1} + (x^n + r)f_{2} + f_3
$$</p>
<p>令</p>
<p>$$
\begin{aligned}
O_1 &amp;= f \bmod (x^n + r) = -2r f_1 + f_3\\
O_2 &amp;= f \bmod (x^n - r) = 2r f_2 + f_3
\end{aligned}
$$</p>
<p>故</p>
<p>$$
f \bmod (x^{2n} - r^2) = \frac{O_2-O_1}{2r}x^n + \frac{O_2 + O_1}{2} = I_1 x^n + I_2
$$</p>
<p>注意到代码中我们并没有直接求 $O_1$，而是对第 $j$ 位乘上了 $\zeta_{2n}^j$，即求的是 $f(\zeta_{2n}x)$。</p>
<p>可以发现</p>
<p>$$
f(\zeta_{2n}x) \bmod (x^n-1) = f(\zeta_{2n}x) \bmod ((\zeta_{2n} x)^n - 1) = f(x) \bmod (x^n + 1)
$$</p>
<p>这个图并不好理解，下面那张 Original FFT 更容易理解，但是现在广为流传的算法是 Twisted FFT。</p>
<p><img loading="lazy" src="../img/fft-twisted.png" alt=""  />
</p>
<p>通过图可以看出，FFT 的过程即是先把多项式从根推到叶子，即求得所有单位根处的值，做完操作后，再从叶子推回根。</p>
<h3 id="original-fft">Original FFT<a hidden class="anchor" aria-hidden="true" href="#original-fft">#</a></h3>
<p>当然，我们可以直接分治，便是 Original FFT。</p>
<p><img loading="lazy" src="../img/fft-original.png" alt=""  />
</p>
<p>由于篇幅有限，本文不展开。</p>
<h3 id="预处理单位根">预处理单位根<a hidden class="anchor" aria-hidden="true" href="#预处理单位根">#</a></h3>
<p>每次计算都重新计算一遍单位根太浪费了，我们可以预处理它，从而在计算中调用。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-cpp" data-lang="cpp"><span class="n">vector</span><span class="o">&lt;</span><span class="n">img</span><span class="o">&gt;</span> <span class="n">ROOT</span><span class="p">;</span>

<span class="kt">void</span> <span class="nf">init</span><span class="p">(</span><span class="kt">int</span> <span class="n">n</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">static</span> <span class="kt">int</span> <span class="n">lim</span> <span class="o">=</span> <span class="p">(</span><span class="n">ROOT</span> <span class="o">=</span> <span class="p">{{</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">}},</span> <span class="mi">1</span><span class="p">);</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">lim</span> <span class="o">&gt;=</span> <span class="n">n</span><span class="p">)</span>
        <span class="k">return</span><span class="p">;</span>
    <span class="n">ROOT</span><span class="p">.</span><span class="n">resize</span><span class="p">(</span><span class="n">n</span><span class="p">);</span>
    <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">l</span> <span class="o">=</span> <span class="n">lim</span><span class="p">;</span> <span class="n">l</span> <span class="o">&lt;</span> <span class="n">n</span><span class="p">;</span> <span class="n">l</span> <span class="o">*=</span> <span class="mi">2</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">img</span> <span class="n">w</span> <span class="o">=</span> <span class="p">{</span><span class="n">cos</span><span class="p">(</span><span class="n">PI</span> <span class="o">/</span> <span class="n">l</span> <span class="o">/</span> <span class="mi">2</span><span class="p">),</span> <span class="n">sin</span><span class="p">(</span><span class="n">PI</span> <span class="o">/</span> <span class="n">l</span> <span class="o">/</span> <span class="mi">2</span><span class="p">)};</span>
        <span class="n">ROOT</span><span class="p">[</span><span class="n">l</span><span class="p">]</span> <span class="o">=</span> <span class="n">w</span><span class="p">;</span>
        <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">l</span><span class="p">;</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span>
            <span class="n">ROOT</span><span class="p">[</span><span class="n">i</span> <span class="o">+</span> <span class="n">l</span><span class="p">]</span> <span class="o">=</span> <span class="n">ROOT</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">*</span> <span class="n">w</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="n">lim</span> <span class="o">=</span> <span class="n">n</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div><h3 id="其他应用">其他应用<a hidden class="anchor" aria-hidden="true" href="#其他应用">#</a></h3>
<p>FFT 实际上是一个工具，用于快速计算卷积，这篇文章我想更聚焦于理解 FFT 的计算过程。</p>
<p>FFT 还有很多应用，比如快速加法，带通配文本匹配等，后面等再刷些题了可能会开一篇讲一讲这个，现在我积累的还不够。</p>
<h2 id="refence">Refence<a hidden class="anchor" aria-hidden="true" href="#refence">#</a></h2>
<ol>
<li><a href="https://oi-wiki.org/math/poly/fft/">OI-Wiki 快速傅里叶变换</a></li>
<li><a href="https://loj.ac/d/3165">FFT 入门笔记 - hly1024</a></li>
</ol>


  </div>
  <footer class="post-footer">
    <ul class="post-tags">
      <li><a href="https://rogeryoungh.github.io/blog/tags/%E5%A4%9A%E9%A1%B9%E5%BC%8F/">多项式</a></li>
    </ul>
<nav class="paginav">
  <a class="prev" href="https://rogeryoungh.github.io/blog/post/poly-newton/">
    <span class="title">« Prev Page</span>
    <br>
    <span>多项式牛顿迭代的分块优化</span>
  </a>
  <a class="next" href="https://rogeryoungh.github.io/blog/post/hello-world-hugo/">
    <span class="title">Next Page »</span>
    <br>
    <span>迁移博客到 Hugo</span>
  </a>
</nav>
<blockquote>
    <p class="copyright-item">
        本文作者： rogeryoungh。
        许可协议：<a href="https://creativecommons.org/licenses/by-sa/4.0/deed.zh" target="_blank">CC BY-SA 4.0</a>。
        转载请署名！
    </p>
    <p class="copyright-item">
        撰写时间：2021-07-22，
        <a href="https://github.com/rogeryoungh/blog/commits/main/content/post/learn-fft.md" target="_blank">更新历史</a>。
    </p>
</blockquote>
  </footer><div id="vcomments"></div>
<script src='//cdn.jsdelivr.net/npm/valine@1/dist/Valine.min.js'></script>
<script type="text/javascript">
    new Valine({
        el: '#vcomments',
        appId: 'FIvl3vmw2mH3naQEJhErblHr-gzGzoHsz',
        appKey: 'BhvzpBrJqPPzfK5phjDBiBb4',
        avatar: 'mp',
        placeholder: '说点什么吧...',
        visitor: 'false'
    });
</script>
</article>
    </main>
    <footer class="footer">
    <span>© 2021 <a href="/blog">Roger Young</a></span>
    <span>
        Powered by
        <a href="https://gohugo.io/" rel="noopener noreferrer" target="_blank">Hugo</a> &
        <a href="https://git.io/hugopapermod" rel="noopener" target="_blank">PaperMod</a>
    </span>
</footer>
<a href="#top" id="gototop" aria-label="go to top" title="Go to Top (Alt + G)">
    <button class="top-link" id="top-link" type="button" accesskey="g">
        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentColor">
            <path d="M12 6H0l6-6z" />
        </svg>
    </button>
</a>

<script>
    let menu = document.getElementById('menu')
    menu.scrollLeft = localStorage.getItem("menu-scroll-position");
    menu.onscroll = function () {
        localStorage.setItem("menu-scroll-position", menu.scrollLeft);
    }

    document.querySelectorAll('a[href^="#"]').forEach(anchor => {
        anchor.addEventListener("click", function (e) {
            e.preventDefault();
            var id = this.getAttribute("href").substr(1);
            if (!window.matchMedia('(prefers-reduced-motion: reduce)').matches) {
                document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView({
                    behavior: "smooth"
                });
            } else {
                document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView();
            }
            if (id === "top") {
                history.replaceState(null, null, " ");
            } else {
                history.pushState(null, null, `#${id}`);
            }
        });
    });

</script>
<script>
    var mybutton = document.getElementById("top-link");
    window.onscroll = function () {
        if (document.body.scrollTop > 800 || document.documentElement.scrollTop > 800) {
            mybutton.style.visibility = "visible";
            mybutton.style.opacity = "1";
        } else {
            mybutton.style.visibility = "hidden";
            mybutton.style.opacity = "0";
        }
    };

</script>
<script>
    document.getElementById("theme-toggle").addEventListener("click", () => {
        if (document.body.className.includes("dark")) {
            document.body.classList.remove('dark');
            localStorage.setItem("pref-theme", 'light');
        } else {
            document.body.classList.add('dark');
            localStorage.setItem("pref-theme", 'dark');
        }
    })
    document.getElementById("font-toggle").addEventListener("click", () => {
        if (document.body.className.includes("serif")) {
            document.body.classList.remove('serif');
            localStorage.setItem("pref-font", 'sans');
        } else {
            document.body.classList.add('serif');
            localStorage.setItem("pref-font", 'serif');
        }
    })

</script>
<script>
    document.querySelectorAll('pre > code').forEach((codeblock) => {
        const container = codeblock.parentNode.parentNode;

        const copybutton = document.createElement('button');
        copybutton.classList.add('copy-code');
        copybutton.innerText = 'copy';

        function copyingDone() {
            copybutton.innerText = 'copied!';
            setTimeout(() => {
                copybutton.innerText = 'copy';
            }, 2000);
        }

        copybutton.addEventListener('click', (cb) => {
            if ('clipboard' in navigator) {
                navigator.clipboard.writeText(codeblock.textContent);
                copyingDone();
                return;
            }

            const range = document.createRange();
            range.selectNodeContents(codeblock);
            const selection = window.getSelection();
            selection.removeAllRanges();
            selection.addRange(range);
            try {
                document.execCommand('copy');
                copyingDone();
            } catch (e) { };
            selection.removeRange(range);
        });

        if (container.classList.contains("highlight")) {
            container.appendChild(copybutton);
        } else if (container.parentNode.firstChild == container) {
            
        } else if (codeblock.parentNode.parentNode.parentNode.parentNode.parentNode.nodeName == "TABLE") {
            
            codeblock.parentNode.parentNode.parentNode.parentNode.parentNode.appendChild(copybutton);
        } else {
            
            codeblock.parentNode.appendChild(copybutton);
        }
    });
</script></body>

</html>
