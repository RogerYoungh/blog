<!DOCTYPE html>
<html><head>

  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />

  <meta name="generator" content="Hugo 0.110.0-DEV">

  
  
  <link rel="stylesheet" href="/scss/index.min.95ba81376e079da48068412714d3b5b407c6cec0c5edbf6ebc255278b7938d7c.css">

</head>
<body>
  <div id="app"><header class="py-5 text-4 flex justify-center shadow print:hidden color-primary">
  <nav class="mx-20 w-full max-w-240 flex flex-wrap justify-center items-center whitespace-nowrap sm:flex-nowrap sm:justify-between">
    <div class="flex basis-full items-stretch justify-center sm:basis-auto">
      <img class="w-12 h-12 self-center" src="https://rogery.dev/img/logo.png">
      <a class="pl-5 font-bold flex self-center text-5" href="/"> Roger Young </a>
    </div>
    <ul class="pl-0 flex mt-5 self-center sm:mt-0">
      <button class="m-3 self-center" id="theme-switcher">
        <i class="i-carbon-automatic text-4">Sun</i>
      </button>
      <li class="flex"><a class="m-3" href="/post">Posts</a></li>
      <li class="flex"><a class="m-3" href="/tag">Tag</a></li>
      <li class="flex"><a class="m-3" href="/about">About</a></li>
    </ul>
  </nav>
</header>


<main class="px-5 flex justify-center">
  <article class="article w-full max-w-210 my-10">
    <header class="my-20">
      <h1 class="text-8 text-center folt-bold"> FFT &amp; NTT 学习笔记 </h1>
      <a
        class="text-center-my-6 hidden print:block"
        href="https://rogery.dev/">
        rogeryoungh
      </a>
      <div class="text-center"> 2021 年 7 月 22 日 </div>
    </header>
    
      <h1> 目录 </h1><nav id="TableOfContents">
  <ol>
    <li><a href="#fft">FFT</a>
      <ol>
        <li><a href="#多项式乘法">多项式乘法</a></li>
        <li><a href="#点值表示法">点值表示法</a></li>
        <li><a href="#dft">DFT</a></li>
        <li><a href="#单位原根">单位原根</a></li>
        <li><a href="#分治">分治</a></li>
        <li><a href="#蝴蝶变换">蝴蝶变换</a></li>
      </ol>
    </li>
    <li><a href="#ntt">NTT</a>
      <ol>
        <li><a href="#原根">原根</a></li>
        <li><a href="#快速数论变换">快速数论变换</a></li>
      </ol>
    </li>
    <li><a href="#线性变换">线性变换</a>
      <ol>
        <li><a href="#干掉-rev">干掉 REV</a></li>
        <li><a href="#另一种理解">另一种理解</a></li>
        <li><a href="#original-fft">Original FFT</a></li>
        <li><a href="#预处理单位根">预处理单位根</a></li>
        <li><a href="#其他应用">其他应用</a></li>
      </ol>
    </li>
    <li><a href="#refence">Refence</a></li>
  </ol>
</nav>
    <section class="content-frame my-10">
      <p>以下是我对 FFT 的感性理解，可能并不严谨，如有错误欢迎指正。</p>
<h2 id="fft">FFT</h2>
<p>以下讲述的算法是 Cooley–Tukey FFT，它在算法竞赛中使用的更为广泛。</p>
<p>前置知识：复数，需要理解 Euler 公式。</p>
<h3 id="多项式乘法">多项式乘法</h3>
<p>对于  $n$  次多项式</p>
<p> $$
\begin{aligned}
f(x) = \sum_{i=0}^n f_ix^i &=  f_0 + f_1 x + f_2x^2 + \cdots + g_nx^n \\
g(x) = \sum_{i=0}^n g_ix^i &=  g_0 + g_1 x + g_2x^2 + \cdots + g_nx^n
\end{aligned}
$$ </p>
<p>它们的卷积是  $F(x) = f(x) \ast g(x) = (f \ast g)(x) = \sum\limits_{k=0}^{2n} c_kx^k$ ，其中</p>
<p> $$
c_k = \sum_{i+j=k}f_ig_j
$$ </p>
<p>因此朴素的计算多项式的卷积需要  $n^2$  次系数乘法，我们需要优化。</p>
<h3 id="点值表示法">点值表示法</h3>
<p> $n$  次多项式  $f(x)$  可以由  $n+1$  个系数决定，也可以由  $n+1$  个座标（点值）决定。即  $n$  次多项式可以看作  $n+1$  维的向量。</p>
<p>考虑选取  $2n+1$  个座标来确定  $f(x)$  和  $g(x)$ 。则  $F(x)$  可以简单的通过做  $2n+1$  次乘法得到</p>
<p> $$
(x_k,F(x_k)) = \left(x_k, f(x_k)g(x_k)\right)
$$ </p>
<p>现在我们有了新的思路：先从系数表示法转换为点值表示法，做完乘法后再变回去。</p>
<h3 id="dft">DFT</h3>
<p>怎么把多项式转换成点值呢？我们有离散 Fourier 变换。</p>
<p>称方程  $x^n = 1$  的  $n$  个解为单位根  $\zeta_n$ 。对于给定的多项式  $f(x) = \sum\limits_{k=0}^{n-1} f_kx^k$  和一个单位根  $\zeta_n$ ，称向量</p>
<p> $$
\operatorname{DFT}_{\zeta_n}(f) =( f(1), f(\zeta_n^1), \cdots, f(\zeta_n^{n-1}) )
$$ </p>
<p>为  $f$  的离散 Fourier 变换（Discrete Fourier Transform）。</p>
<p>DFT 存在逆变换（IDFT），即从点值重新变回系数，仍是从向量到向量的变换。</p>
<p>IDFT 具有一个关键性质</p>
<p> $$
(\operatorname{DFT}_{\zeta})^{-1} = \frac{1}{n} (\operatorname{DFT}_{{\zeta}^{-1}}) \tag{1}
$$ </p>
<p>我们将在后文证明它。现在我们可以统一的处理 DFT 和 IDFT。</p>
<p>为了方便描述，接下来我们将把  $\operatorname{DFT}_{\zeta_n}$  简单的记作  $\mathcal{F}_n$ 。</p>
<h3 id="单位原根">单位原根</h3>
<p>至此，我们计算 DFT 的复杂度仍然是  $O(n^2)$ ，FFT 所迈出的关键一步是选取特殊的点加速计算。</p>
<p>单位根中特殊的一个记作  $\zeta_n = e^{\frac{2 \pi i}{n}}$ ，它叫做单位原根。依 Euler 公式，有</p>
<p> $$
\zeta_n = e^{\tfrac{2 \pi i}{n}} = \cos \left(\frac{2\pi}{n}\right) + i \sin \left(\frac{2\pi}{n}\right)
$$ </p>
<p>即  $\zeta_n$  是单位圆上的一个点，全部的  $n$  个单位根</p>
<p> $$
x_k = \zeta_n^k = e^{k\tfrac{2 \pi i}{n}} = \cos \left(\frac{2\pi k}{n}\right) + i \sin \left(\frac{2\pi k}{n}\right) 
$$ </p>
<p>恰对应到单位圆的  $n$  等分点。因此根据 Euler 公式，<strong>单位根之间的乘法就是在单位圆上转圈圈。</strong></p>
<p>不难通过 Euler 公式验证单位原根  $\zeta_n$  的几条性质：</p>
<ul>
<li> $\zeta_{2n}^{2k} = \zeta_n^k$ 。</li>
<li> $\zeta_{2n}^{n+k} = -\zeta_{2n}^k$ 。</li>
</ul>
<h3 id="分治">分治</h3>
<p>利用单位原根的特殊性，我们可以分治计算 DFT。比如对于  $7$  次多项式</p>
<p> $$
\begin{aligned}
f(x) &= f_0 + f_1x + f_2x^2 + f_3 x^3 + f_4 x^4 + f_5 x^5 + f_6 x^6 + f_7 x^7 \\
&= (f_0 + f_2x^2 + f_4x^4 + f_6x^6) + x(f_1 + f_3x^2 + f_5x^4 + f_7x^6)
\end{aligned}
$$ </p>
<p>奇偶分类</p>
<p> $$
\begin{aligned}
f^{[0]}(x) &= f_0 + f_2x + f_4x^2 + f_6x^3 \\
f^{[1]}(x) &= f_1 + f_3x + f_5x^2 + f_7x^3
\end{aligned}
$$ </p>
<p>则原来的函数可以表示为</p>
<p> $$
f(x) = f^{[0]}(x^2) + xf^{[1]}(x^2)
$$ </p>
<p>一般的，对于度小于  $n$  的多项式  $f(x)$ ，在单位根  $x = \zeta_n^k$  处的点值是</p>
<p> $$
\begin{aligned}
f(\zeta_n^k) &= f^{[0]}(\zeta_n^k \cdot \zeta_n^k) + \zeta_n^kf^{[1]}(\zeta_n^k \cdot \zeta_n^k) \\
&= f^{[0]}(\zeta_n^{2k}) + \zeta_n^kf^{[1]}(\zeta_n^{2k}) \\
&= f^{[0]}(\zeta_{n/2}^{k}) + \zeta_n^kf^{[1]}(\zeta_{n/2}^{k})
\end{aligned}
$$ </p>
<p>同理可得</p>
<p> $$
\begin{aligned}
f(\zeta_n^{k+n/2}) &= f^{[0]}(\zeta_n^{2k+n}) + \zeta_n^{k+n/2}f^{[1]}(\zeta_n^{2k+n}) \\
&= f^{[0]}(\zeta_{n/2}^{k}) - \zeta_n^{k}f^{[1]}(\zeta_{n/2}^{k})
\end{aligned}
$$ </p>
<p>在 DFT 中使用有</p>
<p> $$
\begin{aligned}
\mathcal{F}_n(f)[j] &= \mathcal{F}_{n/2}(f^{[0]})[j] + \zeta_n^j \mathcal{F}_{n/2}(f^{[1]})[j] \\
\mathcal{F}_n(f)[j + n/2] &= \mathcal{F}_{n/2}(f^{[0]})[j] - \zeta_n^j\mathcal{F}_{n/2}(f^{[1]})[j]
\end{aligned}
\tag{2}
$$ </p>
<p>因此我们需要把多项式的系数个数向上补到  $2^n$ ，方便分治。</p>
<p>至此，我们可以写出递归版的 FFT。</p>
<pre><code class="language-cpp">void fft(int n, img *f, int op) {
    static img tmp[1 &lt;&lt; 18];
    if (n == 1)
        return;
    for (int i = 0; i &lt; n; i++)
        tmp[i] = f[i];
    for (int i = 0; i &lt; n; i++) {  // 偶数放左边，奇数放右边
        if (i &amp; 1)
            f[n / 2 + i / 2] = tmp[i];
        else
            f[i / 2] = tmp[i];
    }
    img *g = f, *h = f + n / 2;
    fft(n / 2, g, op), fft(n / 2, h, op);
    img w0 = {cos(2 * PI / n), sin(2 * PI * op / n)}, w = {1, 0};
    for (int k = 0; k &lt; n / 2; k++) {
        tmp[k] = g[k] + w * h[k];
        tmp[k + n / 2] = g[k] - w * h[k];
        w = w * w0;
    }
    for (int i = 0; i &lt; n; i++)
        f[i] = tmp[i];
}
</code></pre>
<h3 id="蝴蝶变换">蝴蝶变换</h3>
<p>递归分治总是不尽人意的，我们在前几行只是做了递归分组的事情，可以考虑一步到位。</p>
<p>还是以  $7$  次多项式为例</p>
<ul>
<li>初始  $\{x^0,x^1,x^2,x^3,x^4,x^5,x^6,x^7\}$ </li>
<li>一次  $\{x^0,x^2,x^4,x^6\},\{x^1,x^3,x^5,x^7\}$ </li>
<li>两次  $\{x^0,x^4\},\{x^2,x^6\},\{x^1,x^5\},\{x^3,x^7\}$ </li>
<li>结束  $\{x^0\},\{x^4\},\{x^2\},\{x^6\},\{x^1\},\{x^5\},\{x^3\},\{x^7\}$ </li>
</ul>
<p>写出二进制的形式，可以发现：结束和开始的二进制恰好是相反的。</p>
<table>
<thead>
<tr>
<th style="text-align:center">初始</th>
<th style="text-align:center">0</th>
<th style="text-align:center">1</th>
<th style="text-align:center">2</th>
<th style="text-align:center">3</th>
<th style="text-align:center">4</th>
<th style="text-align:center">5</th>
<th style="text-align:center">6</th>
<th style="text-align:center">7</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">初始(2)</td>
<td style="text-align:center">000</td>
<td style="text-align:center">001</td>
<td style="text-align:center">010</td>
<td style="text-align:center">011</td>
<td style="text-align:center">100</td>
<td style="text-align:center">101</td>
<td style="text-align:center">110</td>
<td style="text-align:center">111</td>
</tr>
<tr>
<td style="text-align:center">结束(2)</td>
<td style="text-align:center">000</td>
<td style="text-align:center">100</td>
<td style="text-align:center">010</td>
<td style="text-align:center">110</td>
<td style="text-align:center">001</td>
<td style="text-align:center">101</td>
<td style="text-align:center">011</td>
<td style="text-align:center">111</td>
</tr>
<tr>
<td style="text-align:center">结束</td>
<td style="text-align:center">0</td>
<td style="text-align:center">4</td>
<td style="text-align:center">2</td>
<td style="text-align:center">6</td>
<td style="text-align:center">1</td>
<td style="text-align:center">5</td>
<td style="text-align:center">3</td>
<td style="text-align:center">7</td>
</tr>
</tbody>
</table>
<p>这个变换称为蝴蝶变换，也称位逆序置换（bit-reversal permutation）。</p>
<p>我们可以  $O(n)$  的预处理出变换数组。设 <code>R(x)</code> 是  $x$  的变换结果，则 <code>R(x &gt;&gt; 1)</code> 此时是已知的。即是把 <code>R(x &gt;&gt; 1)</code> 右移一位再补上最高位即可。代码如下</p>
<pre><code class="language-cpp">void pre_rev(int lim) {
    int k = std::__lg(lim);
    rev.resize(lim);
    for (int i = 0; i &lt; lim; ++i) {
        rev[i] = rev[i &gt;&gt; 1] &gt;&gt; 1;
        if (i &amp; 1)
            rev[i] |= lim &gt;&gt; 1;
        // 或者合并写为
        // rev[i] = (rev[i &gt;&gt; 1] &gt;&gt; 1) | ((i &amp; 1) &lt;&lt; (k - 1));
    }
}
</code></pre>
<p>现在我们可以写出非递归版的 FFT。</p>
<pre><code class="language-cpp">void fft(img *f, int n, int op) { // DIT
    for (int i = 0; i &lt; n; ++i)
        if (i &lt; rev[i])
            swap(f[i], f[rev[i]]);
    for (int l = 1; l &lt;= n / 2; l &lt;&lt;= 1) {
        img w0 = {cos(PI / l), sin(PI * op / l)};
        for (int i = 0; i &lt; n; i += l * 2) {
            img w = {1, 0};
            for (int j = 0; j &lt; l; j++) {
                img x = f[i + j], y = w * f[i + j + l];
                f[i + j] = x + y, f[i + j + l] = x - y;
                w = w * w0;
            }
        }
    }
    if (op == -1)
        for (int i = 0; i &lt; n; i++)
            f[i] = f[i] / n;
}
</code></pre>
<h2 id="ntt">NTT</h2>
<p>前置知识：数论基础（整除，同余）。</p>
<p>用 <code>double</code> 去实现整数的乘法是很不优美的，精度、速度都很成问题。实际上，我们可以仅在整数下进行运算。</p>
<h3 id="原根">原根</h3>
<p>我们本质上用到的单位原根  $\zeta_n$  的两个性质是：</p>
<ul>
<li> $\zeta_{n}^{n} = 1$ 。</li>
<li> $\zeta_{2n}^{n} = -1$ 。</li>
</ul>
<p>可以联想到模  $p$  剩余类域  $\mathbb{Z}_p$ ：其中的元素是  $\{0,1,\cdots,p-1\}$ ，其上的运算都是模  $p$  的。由于 Fermat 小定理</p>
<p> $$
a^{\varphi(p)} = a^{p-1} \equiv 1
$$ </p>
<p>即从另一个角度说， $p-1$  个正整数都是同余方程  $x^{p-1} \equiv 1$  的解。</p>
<p>它和单位根有很相似的形式，直觉上  $\mathbb{Z}_p$  也存在类似单位原根的特殊数字。下面我们在  $\mathbb{Z}_p$  上讨论，尝试证明这个数字存在。</p>
<p>定义正整数  $a \in \mathbb{Z}_p$  的阶  $\delta_p(a)$  为最小的  $r$  使得  $a^r \equiv 1$ 。由 Fermat 小定理  $a^{\varphi(p)} \equiv 1$ ，因此  $a$  的阶一定存在且有  $\delta_p(a) \mid \varphi(p)$ 。可以证明</p>
<p> $$
a,a^2,\cdots a^{\delta_p(a)} \tag{3}
$$ </p>
<p>在模  $p$  下余数互不相同。由 Lagrange 定理， $x^{\delta_p(a)} \equiv 1$  的解至多有  $\delta_p(a)$  个，恰是  $(3)$  中所展示的。</p>
<p>通过整除的性质，可以想到只有  $i \bot \delta_p(a)$  才有  $\delta_p(a^i) = \delta_p(a)$ ，即  $a$  总是附带着</p>
<p> $$
\sum_{i=1}^{\delta_p(a)} [\gcd(i, \delta_p(a)) = 1] = \varphi(\delta_p(a))
$$ </p>
<p>个阶相同的东西。因此阶为  $\delta_p(a)$  的数恰有  $\varphi(\delta_p(a))$  个。</p>
<p>因为每个正整数都有唯一确定的阶，不妨假设对于所有  $d \mid \varphi(p)$ ，阶  $d$  都存在  $\varphi(d)$  个对应的整数，统计整数个数</p>
<p> $$
\sum_{d \mid \varphi(p)} \varphi(d) = \varphi(p) = p - 1
$$ </p>
<p>恰为  $\mathbb{Z}_p$  全部正整数的个数，因此假设成立，也就存在  $a$  使得  $\delta_p(a) = p-1$ 。</p>
<p>我们称这个  $a$  是模  $p$  下的一个原根，常用字母  $g$  表示。</p>
<h3 id="快速数论变换">快速数论变换</h3>
<p>尽可能提取  $p - 1$  的因子  $2$  有</p>
<p> $$
p = N q + 1, N = 2^m
$$ </p>
<p>设  $\mathbb{Z}_p$  的一个原根  $g$ ，将  $g_N \equiv g^q$  看作  $\zeta_n$  的等价。利用二次剩余的知识不难得到  $g_N^N \equiv 1$  和  $g_N^{N/2} \equiv -1$ 。</p>
<p>常见的有</p>
<p> $$
\begin{aligned}
p = 1004535809 = 479 \times 2^{21} + 1&, g = 3 \\
p = 998244353 = 7 \times 17 \times 2^{23} + 1&, g = 3
\end{aligned}
$$ </p>
<p>类似的，我们可以写出程序</p>
<pre><code class="language-cpp">void ntt(ll *f, int n, int type) {
    for (int i = 0; i &lt; n; ++i)
        if (i &lt; rev[i])
            swap(f[i], f[rev[i]]);
    for (int h = 2; h &lt; n; h &lt;&lt;= 1) {
        ll tg = type == 1 ? 3 : g_inv;
        ll gn = qpow(tg, (P - 1) / h);
        for (int j = 0; j &lt; n; j += h) {
            ll g = 1;
            for (int k = j; k &lt; j + h / 2; k++) {
                ll f1 = f[k], f2 = g * f[k + h / 2] % P;
                f[k] = (f1 + f2) % P;
                f[k + h / 2] = (f1 - f2 + P) % P;
                g = g * gn % P;
            }
        }
    }
    ll iv_n = qpow(n);
    if (type == -1)
        for (int i = 0; i &lt; n; i++)
            f[i] = f[i] * iv_n % P;
}
</code></pre>
<p>至此，你已经学会 FFT 了。下面我们将更深入的从数学角度研究 FFT，补足理论基础。</p>
<h2 id="线性变换">线性变换</h2>
<p>DFT 是一个线性变换。换句话说，它可以被写成矩阵乘法的形式</p>
<p> $$
\begin{bmatrix}
    f(\zeta_n^0) \\ f(\zeta_n^1) \\ f(\zeta_n^2) \\ \vdots \\ f(\zeta_n^{n-1})
\end{bmatrix} = \begin{bmatrix}
    1 & 1 & 1 & \cdots & 1 \\
    1 & \zeta_n^1 & \zeta_n^2 & \cdots & \zeta_n^{n-1} \\
    1 & \zeta_n^2 & \zeta_n^4 & \cdots & \zeta_n^{2(n-1)} \\
    \vdots & \vdots & \vdots  & \ddots & \vdots \\
    1 & \zeta_n^{n-1} & \zeta_n^{2(n-1)} & \cdots & \zeta_n^{(n-1)^2}
\end{bmatrix}
\begin{bmatrix}
    f_0 \\ f_1 \\ f_2 \\ \vdots \\ f_{n-1}
\end{bmatrix} 
$$ </p>
<p>我们把中间的那个  $n$  阶的 Vandermonde 方阵记为  $V(\zeta_n) = (\zeta_n^{ij})$ 。</p>
<p>直接计算  $V(\zeta_n)$  的逆很不好算，但是验证下式是对角矩阵还是容易的</p>
<p> $$
V(\zeta_n) V(\zeta_n^{-1}) = (n[i = j]) = n I_n
$$ </p>
<p>即 IDFT 所对应的矩阵为  $V^{-1}(\zeta_n) = \frac{1}{n} V(\zeta_n^{-1})$ ，我们便证明了  $(1)$  式。</p>
<h3 id="干掉-rev">干掉 REV</h3>
<p>其实上文所实现的 FFT 和 IFFT 并不对偶，只是卷积定理使得 IFFT 恰是 FFT 的逆运算。具体的说，我们实现了两个 DIT，因此需要在计算之前进行蝴蝶变换。</p>
<p><img src="https://upload.wikimedia.org/wikipedia/commons/f/f2/DIF_DIT.jpg" alt="Wikipedia"></p>
<p>我们运算的核心内容在于  $(2)$  式，它可以被写做矩阵形式。</p>
<p> $$
\begin{bmatrix}
O_1 \\ O_2
\end{bmatrix} = 
\begin{bmatrix}
1 & \zeta_n^{-j} \\
1 & -\zeta_n^{-j} 
\end{bmatrix} 
\begin{bmatrix}
I_1 \\ I_2
\end{bmatrix}
$$ </p>
<p>对矩阵求逆</p>
<p> $$
\begin{bmatrix}
I_1 \\ I_2
\end{bmatrix} = \frac{1}{2} 
\begin{bmatrix}
1 & 1 \\
\zeta_n^{j} & -\zeta_n^{j} 
\end{bmatrix} 
\begin{bmatrix}
O_1 \\ O_2
\end{bmatrix} \tag{4}
$$ </p>
<p>我们便得到了 DIF。类似的，我们可以实现两个 DIF 作为 FFT，此时蝴蝶变换在计算之后。</p>
<pre><code class="language-cpp">void fft(img *f, int n, int op) { // DIF
    for (int l = n / 2; l &gt;= 1; l &gt;&gt;= 1) {
        img w0 = {cos(PI / l), sin(PI * op / l)};
        for (int i = 0; i &lt; n; i += l * 2) {
            img w = {1, 0};
            for (int j = 0; j &lt; l; j++) {
                img x = f[i + j], y = f[i + j + l];
                f[i + j] = x + y, f[i + j + l] = w * (x - y);
                w = w * w0;
            }
        }
    }
    for (int i = 0; i &lt; n; ++i)
        if (i &lt; rev[i])
            swap(f[i], f[rev[i]]);
    if (op == -1)
        for (int i = 0; i &lt; n; i++)
            f[i] = f[i] / n;
}
</code></pre>
<p>容易发现，若我们以 DIF 作为 FFT，DIT 作为 IFFT，是不需要蝴蝶变换的。</p>
<pre><code class="language-cpp">void fft(img *f, int n) {
    for (int l = n / 2; l &gt;= 1; l &gt;&gt;= 1) {
        img w0 = {cos(PI / l), sin(PI / l)};
        for (int i = 0; i &lt; n; i += l * 2) {
            img w = {1, 0};
            for (int j = 0; j &lt; l; j++) {
                img x = f[i + j], y = f[i + j + l];
                f[i + j] = x + y, f[i + j + l] = w * (x - y);
                w = w * w0;
            }
        }
    }
}

void ifft(img *f, int n) {
    for (int l = 1; l &lt;= n / 2; l &lt;&lt;= 1) {
        img w0 = img{cos(PI / l), sin(PI / l)}.conj();
        for (int i = 0; i &lt; n; i += l * 2) {
            img w = {1, 0};
            for (int j = 0; j &lt; l; j++) {
                img x = f[i + j], y = w * f[i + j + l];
                f[i + j] = x + y, f[i + j + l] = x - y;
                w = w * w0;
            }
        }
    }
    for (int i = 0; i &lt; n; i++)
        f[i] = f[i] / n;
}
</code></pre>
<p>以上，便是 Twisted FFT。</p>
<h3 id="另一种理解">另一种理解</h3>
<p>注意到</p>
<p> $$
f(x_0) = f \bmod (x - x_0)
$$ </p>
<p>我们可以从这方面着手，从取模角度重新审视上述算法。假设  $f$  可以被分解为</p>
<p> $$
f = (x^n - r)(x^n + r)f_{0} + (x^n - r)f_{1} + (x^n + r)f_{2} + f_3
$$ </p>
<p>令</p>
<p> $$
\begin{aligned}
O_1 &= f \bmod (x^n + r) = -2r f_1 + f_3\\
O_2 &= f \bmod (x^n - r) = 2r f_2 + f_3
\end{aligned}
$$ </p>
<p>故</p>
<p> $$
f \bmod (x^{2n} - r^2) = \frac{O_2-O_1}{2r}x^n + \frac{O_2 + O_1}{2} = I_1 x^n + I_2
$$ </p>
<p>注意到代码中我们并没有直接求  $O_1$ ，而是对第  $j$  位乘上了  $\zeta_{2n}^j$ ，即求的是  $f(\zeta_{2n}x)$ 。</p>
<p>可以发现</p>
<p> $$
f(\zeta_{2n}x) \bmod (x^n-1) = f(\zeta_{2n}x) \bmod ((\zeta_{2n} x)^n - 1) = f(x) \bmod (x^n + 1)
$$ </p>
<p>这个图并不好理解，下面那张 Original FFT 更容易理解，但是现在广为流传的算法是 Twisted FFT。</p>
<p><img src="../img/fft-twisted.png" alt=""></p>
<p>通过图可以看出，FFT 的过程即是先把多项式从根推到叶子，即求得所有单位根处的值，做完操作后，再从叶子推回根。</p>
<h3 id="original-fft">Original FFT</h3>
<p>当然，我们可以直接分治，便是 Original FFT。</p>
<p><img src="../img/fft-original.png" alt=""></p>
<p>由于篇幅有限，本文不展开。</p>
<h3 id="预处理单位根">预处理单位根</h3>
<p>每次计算都重新计算一遍单位根太浪费了，我们可以预处理它，从而在计算中调用。</p>
<pre><code class="language-cpp">vector&lt;img&gt; ROOT;

void init(int n) {
    static int lim = (ROOT = {{1, 0}}, 1);
    if (lim &gt;= n)
        return;
    ROOT.resize(n);
    for (int l = lim; l &lt; n; l *= 2) {
        img w = {cos(PI / l / 2), sin(PI / l / 2)};
        ROOT[l] = w;
        for (int i = 1; i &lt; l; ++i)
            ROOT[i + l] = ROOT[i] * w;
    }
    lim = n;
}
</code></pre>
<h3 id="其他应用">其他应用</h3>
<p>FFT 实际上是一个工具，用于快速计算卷积，这篇文章我想更聚焦于理解 FFT 的计算过程。</p>
<p>FFT 还有很多应用，比如快速加法，带通配文本匹配等，后面等再刷些题了可能会开一篇讲一讲这个，现在我积累的还不够。</p>
<h2 id="refence">Refence</h2>
<ol>
<li><a href="https://oi-wiki.org/math/poly/fft/">OI-Wiki 快速傅里叶变换</a></li>
<li><a href="https://loj.ac/d/3165">FFT 入门笔记 - hly1024</a></li>
</ol>

    </section>
    <hr />
    <section class="comment-frame my-10">
      


  <div class="giscus"></div>
<script>
let giscusTheme = localStorage.getItem("giscus-theme");
let giscusAttributes = () => {
  return {
    "src": "https://giscus.app/client.js",
    "data-repo": "rogeryoungh\/blog",
    "data-repo-id": "MDEwOlJlcG9zaXRvcnkzODQyNDIyNTQ=",
    "data-category": "Giscus",
    "data-category-id": "DIC_kwDOFucSTs4CTTLS",
    "data-mapping": "pathname",
    "data-strict": "0",
    "data-reactions-enabled": "1",
    "data-emit-metadata": "0",
    "data-input-position": "bottom",
    "data-theme": isCurrentDark() ? 'dark' : 'light',
    "data-lang": "zh-CN",
    "crossorigin": "anonymous",
    "async": "",
  }
};

document.addEventListener("DOMContentLoaded", function () {
  let giscusScript = document.createElement("script");
  Object.entries(giscusAttributes()).forEach(([key, value]) => giscusScript.setAttribute(key, value));
  document.body.appendChild(giscusScript);
});


function changeGiscusTheme(theme) {
  const sendMessage = (message) => {
    const iframe = document.querySelector('iframe.giscus-frame');
    if (!iframe) return;
    iframe.contentWindow.postMessage({ giscus: message }, 'https://giscus.app');
  }
  sendMessage({
    setConfig: {
      theme: theme
    }
  });
}
</script>



    </section>
  </article>
</main>


<footer class="my-10 color-secondary text-3 flex items-end justify-center a-underline">
  <span>
    © 2021 <a href="https://acm.rogery.dev">Roger Young</a>
  </span>
  <i class="i-carbon-lighting inline-block px-1"></i>
  <span>Powered by <a href="https://gohugo.io/">Hugo</a> &
    <a href="https://github.com/rogeryoungh/hugo-pure">pure</a>
  </span>
</footer>
</div>
  <div>
    
  <link
  crossorigin="anonymous"
  integrity="sha512-mQwom8Ns4op+H29oDkD/LXO/OsXPvCFfkgZkFAVrhhePzRLU8NUI3Nkm43NhWUSmj3p5Cca2HTEkMQmXQRwDQQ=="
  href="https://lib.baomitu.com/KaTeX/0.16.4/katex.min.css" rel="stylesheet">
<script
  crossorigin="anonymous"
  integrity="sha512-sHSNLECRJSK+BFs7E8DiFc6pf6n90bLI85Emiw1jhreduZhK3VXgq9l4kAt9eTIHYAcuQBKHL01QKs4/3Xgl8g=="
  src="https://lib.baomitu.com/KaTeX/0.16.4/katex.min.js"></script>
<script
  crossorigin="anonymous"
  integrity="sha512-iWiuBS5nt6r60fCz26Nd0Zqe0nbk1ZTIQbl3Kv7kYsX+yKMUFHzjaH2+AnM6vp2Xs+gNmaBAVWJjSmuPw76Efg=="
  src="https://lib.baomitu.com/KaTeX/0.16.4/contrib/auto-render.min.js"></script>

<script>
document.addEventListener("DOMContentLoaded", function () {
  renderMathInElement(document.body, {
    delimiters: [
      { left: '$$', right: '$$', display: true },
      { left: '$', right: '$', display: false },
      { left: '\\(', right: '\\)', display: false },
      { left: '\\[', right: '\\]', display: true },
    ],
    globalGroup: true,
    throwOnError: false
  });
});
</script>




  <script
  crossorigin="anonymous"
  src="https://lib.baomitu.com/prism/1.29.0/prism.min.js"></script>
<script
  crossorigin="anonymous"
  src="https://lib.baomitu.com/prism/1.29.0/plugins/autoloader/prism-autoloader.min.js"></script>



<script>
let themeSwitch = document.getElementById("theme-switcher");
var icon = themeSwitch.children[0];
let currentPref = localStorage.getItem('pref-theme') || 'auto';
let html = document.documentElement;
let windowPref = window.matchMedia('(prefers-color-scheme: dark)');
function isCurrentDark() {
  let isDark = false;
  if (currentPref === 'light') {
    isDark = false;
  } else if (currentPref === 'dark') {
    isDark = true;
  } else {
    isDark = windowPref.matches;
  }
  return isDark;
}
let reloadTheme = () => {
  icon.classList.remove('i-carbon-moon');
  icon.classList.remove('i-carbon-sun');
  icon.classList.remove('i-carbon-automatic');
  if (currentPref === 'light') {
    icon.classList.add('i-carbon-sun');
  } else if (currentPref === 'dark') {
    icon.classList.add('i-carbon-moon');
  } else {
    icon.classList.add('i-carbon-automatic');
  }
  if (isCurrentDark()) {
    html.classList.add('dark');
  } else {
    html.classList.remove('dark');
  }
  
    changeGiscusTheme(isCurrentDark() ? 'dark' : 'light');
  
};
themeSwitch.addEventListener("click", () => {
  icon.classList.remove('i-carbon-moon');
  icon.classList.remove('i-carbon-sun');
  icon.classList.remove('i-carbon-automatic');
  if (currentPref === 'auto') {
    currentPref = 'dark';
    icon.classList.add('i-carbon-moon');
  } else if (currentPref === 'dark') {
    currentPref = 'light';
    icon.classList.add('i-carbon-sun');
  } else {
    currentPref = 'auto';
    icon.classList.add('i-carbon-automatic');
  }
  localStorage.setItem("pref-theme", currentPref);
  reloadTheme();
});
reloadTheme();
</script>


  </div>
</body>

</html>
