<!DOCTYPE html>
<html><head>

  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />

  <meta name="generator" content="Hugo 0.110.0-DEV">

  
  
  <link rel="stylesheet" href="/scss/index.min.95ba81376e079da48068412714d3b5b407c6cec0c5edbf6ebc255278b7938d7c.css">

</head>
<body>
  <div id="app"><header class="py-5 text-4 flex justify-center shadow print:hidden color-primary">
  <nav class="mx-20 w-full max-w-240 flex flex-wrap justify-center items-center whitespace-nowrap sm:flex-nowrap sm:justify-between">
    <div class="flex basis-full items-stretch justify-center sm:basis-auto">
      <img class="w-12 h-12 self-center" src="https://rogery.dev/img/logo.png">
      <a class="pl-5 font-bold flex self-center text-5" href="/"> Roger Young </a>
    </div>
    <ul class="pl-0 flex mt-5 self-center sm:mt-0">
      <button class="m-3 self-center" id="theme-switcher">
        <i class="i-carbon-automatic text-4">Sun</i>
      </button>
      <li class="flex"><a class="m-3" href="/post">Posts</a></li>
      <li class="flex"><a class="m-3" href="/tag">Tag</a></li>
      <li class="flex"><a class="m-3" href="/about">About</a></li>
    </ul>
  </nav>
</header>


<main class="px-5 flex justify-center">
  <article class="article w-full max-w-210 my-10">
    <header class="my-20">
      <h1 class="text-8 text-center folt-bold"> 满二叉树的非递归 DFS 序遍历 </h1>
      <a
        class="text-center-my-6 hidden print:block"
        href="https://rogery.dev/">
        rogeryoungh
      </a>
      <div class="text-center"> 2024 年 1 月 12 日 </div>
    </header>
    
      <h1> 目录 </h1><nav id="TableOfContents">
  <ol>
    <li><a href="#bfs-序">BFS 序</a></li>
    <li><a href="#dfs-序">DFS 序</a>
      <ol>
        <li><a href="#先序遍历">先序遍历</a></li>
        <li><a href="#中序遍历">中序遍历</a></li>
        <li><a href="#后序遍历">后序遍历</a></li>
      </ol>
    </li>
    <li><a href="#最低步长">最低步长</a>
      <ol>
        <li><a href="#先序遍历step">先序遍历（step）</a></li>
        <li><a href="#中序遍历step">中序遍历（step）</a></li>
        <li><a href="#后序遍历step">后序遍历（step）</a></li>
      </ol>
    </li>
    <li><a href="#后记">后记</a></li>
  </ol>
</nav>
    <section class="content-frame my-10">
      <p><a href="https://oi-wiki.org/misc/cdq-divide/">CDQ 分治</a> 是一种分治合并贡献的思想，主要是在递归树上遍历。半在线卷积算法其中就有 CDQ 分治的思想，而且其递归树是满二叉树。</p>
<p>很久以前造半在线卷积的时候，为了让分治与数据流解偶，想办法用位运算 <a href="https://www.luogu.com.cn/blog/rogeryoungh/ban-zai-xian-juan-ji-di-shi-xian">改造成 next 形式</a>。<a href="https://blog.asukakyle.top/">@HolyK</a> 似乎更早的注意到这一点（原博客好像消失了），并总结出相当一部分的 CDQ 都可以应用这种技巧。</p>
<p>考研学到二叉树时又捡起这个想法，半在线卷积只是中序遍历，其他序能不能也这样做呢？</p>
<p>本文主要总结了满二叉树的非递归实现，即需要保证  $n$  具有  $2^k$  的形式。</p>
<h2 id="bfs-序">BFS 序</h2>
<p>BFS 序即层序遍历，大家应该比较熟悉了。FFT 的迭代版一般用这个。</p>
<pre><code class="language-cpp">void levelorder1(int n) { // 自底向上
  for (int l = 1; l &lt;= n; l *= 2) {
    for (int i = 0; i &lt; n; i += l) {
      std::printf(&quot;[%d, %d)\t\n&quot;, i, i + l);
    }
  }
}

void levelorder2(int n) { // 自顶向下
  for (int l = n; l &gt;= 1; l /= 2) {
    for (int i = 0; i &lt; n; i += l) {
      std::printf(&quot;[%d, %d)\t\n&quot;, i, i + l);
    }
  }
}
</code></pre>
<h2 id="dfs-序">DFS 序</h2>
<p>DFS 序有三种：</p>
<ul>
<li>先序遍历：根左右</li>
<li>中序遍历：左根右</li>
<li>后序遍历：左右根</li>
</ul>
<h3 id="先序遍历">先序遍历</h3>
<p>注意到当前点的 lowbit 指示了其作为左边界的最大覆盖区间。</p>
<pre><code class="language-cpp">void preorder(int n) { // 根左右
  for (int i = 0; i &lt; n; ++i) {
    int u = i == 0 ? n : (i &amp; -i);
    for (; u &gt; 0; u /= 2) {
      std::printf(&quot;[%d, %d)\n&quot;, i, i + u);
    }
  }
}
</code></pre>
<h3 id="中序遍历">中序遍历</h3>
<p>注意到当前点的 lowbit 指示了其左右范围。</p>
<pre><code class="language-cpp">void inorder(int n) { // 左根右
  for (int i = 1; i &lt; n; ++i) {
    int u = i &amp; -i;
    if (u == 1) {
      std::printf(&quot;[%d, %d)\n&quot;, i - 1, i);
      std::printf(&quot;[%d, %d)\n&quot;, i - u, i + u);
      std::printf(&quot;[%d, %d)\n&quot;, i, i + 1);
    } else {
      std::printf(&quot;[%d, %d)\n&quot;, i - u, i + u);
    }
  }
}
</code></pre>
<h3 id="后序遍历">后序遍历</h3>
<p>后序遍历直接测试即可。</p>
<pre><code class="language-cpp">void postorder(int n) { // 左右根
  for (int i = 1; i &lt;= n; ++i) {
    int u = 1;
    while (true) {
      std::printf(&quot;[%d, %d)\n&quot;, i - u, i);
      if (u &amp; i)
        break;
      u *= 2;
    }
  }
}
</code></pre>
<h2 id="最低步长">最低步长</h2>
<p>有时候我们需要做类似循环展开的优化，加入了最低步长的控制。</p>
<h3 id="先序遍历step">先序遍历（step）</h3>
<pre><code class="language-cpp">void preorder(int n, int step = 1) { // 根左右
  for (int i = 0; i &lt; n; i += step) {
    int u = i == 0 ? n : (i &amp; -i);
    for (; u &gt;= step; u /= 2) {
      std::printf(&quot;[%d, %d)\n&quot;, i, i + u);
    }
  }
}
</code></pre>
<h3 id="中序遍历step">中序遍历（step）</h3>
<pre><code class="language-cpp">void inorder(int n, int step = 1) { // 左根右
  for (int i = step; i &lt; n; i += step) {
    int l = i &amp; -i;
    if (l == step) {
      std::printf(&quot;[%d, %d)\n&quot;, i - step, i);
      std::printf(&quot;[%d, %d)\n&quot;, i - l, i + l);
      std::printf(&quot;[%d, %d)\n&quot;, i, i + step);
    } else {
      std::printf(&quot;[%d, %d)\n&quot;, i - l, i + l);
    }
  }
}
</code></pre>
<h3 id="后序遍历step">后序遍历（step）</h3>
<pre><code class="language-cpp">void postorder(int n, int step = 1) { // 左右根
  for (int i = step; i &lt;= n; i += step) {
    int l = step;
    while (true) {
      std::printf(&quot;[%d, %d)\n&quot;, i - l, i);
      if (l &amp; i)
        break;
      l *= 2;
    }
  }
}
</code></pre>
<h2 id="后记">后记</h2>
<p>不知道能不能整出来非迭代的 DFS 序 FFT。</p>

    </section>
    <hr />
    <section class="comment-frame my-10">
      


  <div class="giscus"></div>
<script>
let giscusTheme = localStorage.getItem("giscus-theme");
let giscusAttributes = () => {
  return {
    "src": "https://giscus.app/client.js",
    "data-repo": "rogeryoungh\/blog",
    "data-repo-id": "MDEwOlJlcG9zaXRvcnkzODQyNDIyNTQ=",
    "data-category": "Giscus",
    "data-category-id": "DIC_kwDOFucSTs4CTTLS",
    "data-mapping": "pathname",
    "data-strict": "0",
    "data-reactions-enabled": "1",
    "data-emit-metadata": "0",
    "data-input-position": "bottom",
    "data-theme": isCurrentDark() ? 'dark' : 'light',
    "data-lang": "zh-CN",
    "crossorigin": "anonymous",
    "async": "",
  }
};

document.addEventListener("DOMContentLoaded", function () {
  let giscusScript = document.createElement("script");
  Object.entries(giscusAttributes()).forEach(([key, value]) => giscusScript.setAttribute(key, value));
  document.body.appendChild(giscusScript);
});


function changeGiscusTheme(theme) {
  const sendMessage = (message) => {
    const iframe = document.querySelector('iframe.giscus-frame');
    if (!iframe) return;
    iframe.contentWindow.postMessage({ giscus: message }, 'https://giscus.app');
  }
  sendMessage({
    setConfig: {
      theme: theme
    }
  });
}
</script>



    </section>
  </article>
</main>


<footer class="my-10 color-secondary text-3 flex items-end justify-center a-underline">
  <span>
    © 2021 <a href="https://acm.rogery.dev">Roger Young</a>
  </span>
  <i class="i-carbon-lighting inline-block px-1"></i>
  <span>Powered by <a href="https://gohugo.io/">Hugo</a> &
    <a href="https://github.com/rogeryoungh/hugo-pure">pure</a>
  </span>
</footer>
</div>
  <div>
    
  <link
  crossorigin="anonymous"
  integrity="sha512-mQwom8Ns4op+H29oDkD/LXO/OsXPvCFfkgZkFAVrhhePzRLU8NUI3Nkm43NhWUSmj3p5Cca2HTEkMQmXQRwDQQ=="
  href="https://lib.baomitu.com/KaTeX/0.16.4/katex.min.css" rel="stylesheet">
<script
  crossorigin="anonymous"
  integrity="sha512-sHSNLECRJSK+BFs7E8DiFc6pf6n90bLI85Emiw1jhreduZhK3VXgq9l4kAt9eTIHYAcuQBKHL01QKs4/3Xgl8g=="
  src="https://lib.baomitu.com/KaTeX/0.16.4/katex.min.js"></script>
<script
  crossorigin="anonymous"
  integrity="sha512-iWiuBS5nt6r60fCz26Nd0Zqe0nbk1ZTIQbl3Kv7kYsX+yKMUFHzjaH2+AnM6vp2Xs+gNmaBAVWJjSmuPw76Efg=="
  src="https://lib.baomitu.com/KaTeX/0.16.4/contrib/auto-render.min.js"></script>

<script>
document.addEventListener("DOMContentLoaded", function () {
  renderMathInElement(document.body, {
    delimiters: [
      { left: '$$', right: '$$', display: true },
      { left: '$', right: '$', display: false },
      { left: '\\(', right: '\\)', display: false },
      { left: '\\[', right: '\\]', display: true },
    ],
    globalGroup: true,
    throwOnError: false
  });
});
</script>




  <script
  crossorigin="anonymous"
  src="https://lib.baomitu.com/prism/1.29.0/prism.min.js"></script>
<script
  crossorigin="anonymous"
  src="https://lib.baomitu.com/prism/1.29.0/plugins/autoloader/prism-autoloader.min.js"></script>



<script>
let themeSwitch = document.getElementById("theme-switcher");
var icon = themeSwitch.children[0];
let currentPref = localStorage.getItem('pref-theme') || 'auto';
let html = document.documentElement;
let windowPref = window.matchMedia('(prefers-color-scheme: dark)');
function isCurrentDark() {
  let isDark = false;
  if (currentPref === 'light') {
    isDark = false;
  } else if (currentPref === 'dark') {
    isDark = true;
  } else {
    isDark = windowPref.matches;
  }
  return isDark;
}
let reloadTheme = () => {
  icon.classList.remove('i-carbon-moon');
  icon.classList.remove('i-carbon-sun');
  icon.classList.remove('i-carbon-automatic');
  if (currentPref === 'light') {
    icon.classList.add('i-carbon-sun');
  } else if (currentPref === 'dark') {
    icon.classList.add('i-carbon-moon');
  } else {
    icon.classList.add('i-carbon-automatic');
  }
  if (isCurrentDark()) {
    html.classList.add('dark');
  } else {
    html.classList.remove('dark');
  }
  
    changeGiscusTheme(isCurrentDark() ? 'dark' : 'light');
  
};
themeSwitch.addEventListener("click", () => {
  icon.classList.remove('i-carbon-moon');
  icon.classList.remove('i-carbon-sun');
  icon.classList.remove('i-carbon-automatic');
  if (currentPref === 'auto') {
    currentPref = 'dark';
    icon.classList.add('i-carbon-moon');
  } else if (currentPref === 'dark') {
    currentPref = 'light';
    icon.classList.add('i-carbon-sun');
  } else {
    currentPref = 'auto';
    icon.classList.add('i-carbon-automatic');
  }
  localStorage.setItem("pref-theme", currentPref);
  reloadTheme();
});
reloadTheme();
</script>


  </div>
</body>

</html>
