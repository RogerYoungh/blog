[{"content":"以下是我对 FFT 的感性理解，可能并不严谨，如有错误欢迎指正。\nFFT 以下讲述的算法是 Cooley–Tukey FFT，它在算法竞赛中使用的更为广泛。\n前置知识：复数，需要理解 Euler 公式。\n多项式乘法 对于 $n$ 次多项式\n$$ \\begin{aligned} f(x) = \\sum_{i=0}^n f_ix^i \u0026amp;= f_0 + f_1 x + f_2x^2 + \\cdots + g_nx^n \\\\ g(x) = \\sum_{i=0}^n g_ix^i \u0026amp;= g_0 + g_1 x + g_2x^2 + \\cdots + g_nx^n \\end{aligned} $$\n它们的卷积是 $F(x) = f(x) \\ast g(x) = (f \\ast g)(x) = \\sum\\limits_{k=0}^{2n} c_kx^k$，其中\n$$ c_k = \\sum_{i+j=k}f_ig_j $$\n因此朴素的计算多项式的卷积需要 $n^2$ 次系数乘法，我们需要优化。\n点值表示法 $n$ 次多项式 $f(x)$ 可以由 $n+1$ 个系数决定，也可以由 $n+1$ 个座标（点值）决定。即 $n$ 次多项式可以看作 $n+1$ 维的向量。\n考虑选取 $2n+1$ 个座标来确定 $f(x)$ 和 $g(x)$。则 $F(x)$ 可以简单的通过做 $2n+1$ 次乘法得到\n$$ (x_k,F(x_k)) = \\left(x_k, f(x_k)g(x_k)\\right) $$\n现在我们有了新的思路：先从系数表示法转换为点值表示法，做完乘法后再变回去。\nDFT 怎么把多项式转换成点值呢？我们有离散 Fourier 变换。\n称方程 $x^n = 1$ 的 $n$ 个解为单位根 $\\zeta_n$。对于给定的多项式 $f(x) = \\sum\\limits_{k=0}^{n-1} f_kx^k$ 和一个单位根 $\\zeta_n$，称向量\n$$ \\operatorname{DFT}_{\\zeta_n}(f) =( f(1), f(\\zeta_n^1), \\cdots, f(\\zeta_n^{n-1}) ) $$\n为 $f$ 的离散 Fourier 变换（Discrete Fourier Transform）。\nDFT 存在逆变换（IDFT），即从点值重新变回系数，仍是从向量到向量的变换。\nIDFT 具有一个关键性质\n$$ (\\operatorname{DFT}_{\\zeta})^{-1} = \\frac{1}{n} (\\operatorname{DFT}_{{\\zeta}^{-1}}) \\tag{1} $$\n我们将在后文证明它。现在我们可以统一的处理 DFT 和 IDFT。\n为了方便描述，接下来我们将把 $\\operatorname{DFT}_{\\zeta_n}$ 简单的记作 $\\mathcal{F}_n$。\n单位原根 至此，我们计算 DFT 的复杂度仍然是 $O(n^2)$，FFT 所迈出的关键一步是选取特殊的点加速计算。\n单位根中特殊的一个记作 $\\zeta_n = e^{\\frac{2 \\pi i}{n}}$，它叫做单位原根。依 Euler 公式，有\n$$ \\zeta_n = e^{\\tfrac{2 \\pi i}{n}} = \\cos \\left(\\frac{2\\pi}{n}\\right) + i \\sin \\left(\\frac{2\\pi}{n}\\right) $$\n即 $\\zeta_n$ 是单位圆上的一个点，全部的 $n$ 个单位根\n$$ x_k = \\zeta_n^k = e^{k\\tfrac{2 \\pi i}{n}} = \\cos \\left(\\frac{2\\pi k}{n}\\right) + i \\sin \\left(\\frac{2\\pi k}{n}\\right) $$\n恰对应到单位圆的 $n$ 等分点。因此根据 Euler 公式，单位根之间的乘法就是在单位圆上转圈圈。\n不难通过 Euler 公式验证单位原根 $\\zeta_n$ 的几条性质：\n $\\zeta_{2n}^{2k} = \\zeta_n^k$。 $\\zeta_{2n}^{n+k} = -\\zeta_{2n}^k$。  分治 利用单位原根的特殊性，我们可以分治计算 DFT。比如对于 $7$ 次多项式\n$$ \\begin{aligned} f(x) \u0026amp;= f_0 + f_1x + f_2x^2 + f_3 x^3 + f_4 x^4 + f_5 x^5 + f_6 x^6 + f_7 x^7 \\\\ \u0026amp;= (f_0 + f_2x^2 + f_4x^4 + f_6x^6) + x(f_1 + f_3x^2 + f_5x^4 + f_7x^6) \\end{aligned} $$\n奇偶分类\n$$ \\begin{aligned} f^{[0]}(x) \u0026amp;= f_0 + f_2x + f_4x^2 + f_6x^3 \\\\ f^{[1]}(x) \u0026amp;= f_1 + f_3x + f_5x^2 + f_7x^3 \\end{aligned} $$\n则原来的函数可以表示为\n$$ f(x) = f^{[0]}(x^2) + xf^{[1]}(x^2) $$\n一般的，对于度小于 $n$ 的多项式 $f(x)$，在单位根 $x = \\zeta_n^k$ 处的点值是\n$$ \\begin{aligned} f(\\zeta_n^k) \u0026amp;= f^{[0]}(\\zeta_n^k \\cdot \\zeta_n^k) + \\zeta_n^kf^{[1]}(\\zeta_n^k \\cdot \\zeta_n^k) \\\\ \u0026amp;= f^{[0]}(\\zeta_n^{2k}) + \\zeta_n^kf^{[1]}(\\zeta_n^{2k}) \\\\ \u0026amp;= f^{[0]}(\\zeta_{n/2}^{k}) + \\zeta_n^kf^{[1]}(\\zeta_{n/2}^{k}) \\end{aligned} $$\n同理可得\n$$ \\begin{aligned} f(\\zeta_n^{k+n/2}) \u0026amp;= f^{[0]}(\\zeta_n^{2k+n}) + \\zeta_n^{k+n/2}f^{[1]}(\\zeta_n^{2k+n}) \\\\ \u0026amp;= f^{[0]}(\\zeta_{n/2}^{k}) - \\zeta_n^{k}f^{[1]}(\\zeta_{n/2}^{k}) \\end{aligned} $$\n在 DFT 中使用有\n$$ \\begin{aligned} \\mathcal{F}_n(f)[j] \u0026amp;= \\mathcal{F}_{n/2}(f^{[0]})[j] + \\zeta_n^j \\mathcal{F}_{n/2}(f^{[1]})[j] \\\\ \\mathcal{F}_n(f)[j + n/2] \u0026amp;= \\mathcal{F}_{n/2}(f^{[0]})[j] - \\zeta_n^j\\mathcal{F}_{n/2}(f^{[1]})[j] \\end{aligned} \\tag{2} $$\n因此我们需要把多项式的系数个数向上补到 $2^n$，方便分治。\n至此，我们可以写出递归版的 FFT。\nvoid fft(int n, img *f, int op) { static img tmp[1 \u0026lt;\u0026lt; 18]; if (n == 1) return; for (int i = 0; i \u0026lt; n; i++) tmp[i] = f[i]; for (int i = 0; i \u0026lt; n; i++) { // 偶数放左边，奇数放右边  if (i \u0026amp; 1) f[n / 2 + i / 2] = tmp[i]; else f[i / 2] = tmp[i]; } img *g = f, *h = f + n / 2; fft(n / 2, g, op), fft(n / 2, h, op); img w0 = {cos(2 * PI / n), sin(2 * PI * op / n)}, w = {1, 0}; for (int k = 0; k \u0026lt; n / 2; k++) { tmp[k] = g[k] + w * h[k]; tmp[k + n / 2] = g[k] - w * h[k]; w = w * w0; } for (int i = 0; i \u0026lt; n; i++) f[i] = tmp[i]; } 蝴蝶变换 递归分治总是不尽人意的，我们在前几行只是做了递归分组的事情，可以考虑一步到位。\n还是以 $7$ 次多项式为例\n 初始 $\\{x^0,x^1,x^2,x^3,x^4,x^5,x^6,x^7\\}$ 一次 $\\{x^0,x^2,x^4,x^6\\},\\{x^1,x^3,x^5,x^7\\}$ 两次 $\\{x^0,x^4\\},\\{x^2,x^6\\},\\{x^1,x^5\\},\\{x^3,x^7\\}$ 结束 $\\{x^0\\},\\{x^4\\},\\{x^2\\},\\{x^6\\},\\{x^1\\},\\{x^5\\},\\{x^3\\},\\{x^7\\}$  写出二进制的形式，可以发现：结束和开始的二进制恰好是相反的。\n   初始 0 1 2 3 4 5 6 7     初始(2) 000 001 010 011 100 101 110 111   结束(2) 000 100 010 110 001 101 011 111   结束 0 4 2 6 1 5 3 7    这个变换称为蝴蝶变换，也称位逆序置换（bit-reversal permutation）。\n我们可以 $O(n)$ 的预处理出变换数组。设 R(x) 是 $x$ 的变换结果，则 R(x \u0026gt;\u0026gt; 1) 此时是已知的。即是把 R(x \u0026gt;\u0026gt; 1) 右移一位再补上最高位即可。代码如下\nvoid pre_rev(int lim) { int k = std::__lg(lim); rev.resize(lim); for (int i = 0; i \u0026lt; lim; ++i) { rev[i] = rev[i \u0026gt;\u0026gt; 1] \u0026gt;\u0026gt; 1; if (i \u0026amp; 1) rev[i] |= lim \u0026gt;\u0026gt; 1; // 或者合并写为  // rev[i] = (rev[i \u0026gt;\u0026gt; 1] \u0026gt;\u0026gt; 1) | ((i \u0026amp; 1) \u0026lt;\u0026lt; (k - 1));  } } 现在我们可以写出非递归版的 FFT。\nvoid fft(img *f, int n, int op) { // DIT  for (int i = 0; i \u0026lt; n; ++i) if (i \u0026lt; rev[i]) swap(f[i], f[rev[i]]); for (int l = 1; l \u0026lt;= n / 2; l \u0026lt;\u0026lt;= 1) { img w0 = {cos(PI / l), sin(PI * op / l)}; for (int i = 0; i \u0026lt; n; i += l * 2) { img w = {1, 0}; for (int j = 0; j \u0026lt; l; j++) { img x = f[i + j], y = w * f[i + j + l]; f[i + j] = x + y, f[i + j + l] = x - y; w = w * w0; } } } if (op == -1) for (int i = 0; i \u0026lt; n; i++) f[i] = f[i] / n; } NTT 前置知识：数论基础（整除，同余）。\n用 double 去实现整数的乘法是很不优美的，精度、速度都很成问题。实际上，我们可以仅在整数下进行运算。\n原根 我们本质上用到的单位原根 $\\zeta_n$ 的两个性质是：\n $\\zeta_{n}^{n} = 1$。 $\\zeta_{2n}^{n} = -1$。  可以联想到模 $p$ 剩余类域 $\\mathbb{Z}_p$：其中的元素是 $\\{0,1,\\cdots,p-1\\}$，其上的运算都是模 $p$ 的。由于 Fermat 小定理\n$$ a^{\\varphi(p)} = a^{p-1} \\equiv 1 $$\n即从另一个角度说，$p-1$ 个正整数都是同余方程 $x^{p-1} \\equiv 1$ 的解。\n它和单位根有很相似的形式，直觉上 $\\mathbb{Z}_p$ 也存在类似单位原根的特殊数字。下面我们在 $\\mathbb{Z}_p$ 上讨论，尝试证明这个数字存在。\n定义正整数 $a \\in \\mathbb{Z}_p$ 的阶 $\\delta_p(a)$ 为最小的 $r$ 使得 $a^r \\equiv 1$。由 Fermat 小定理 $a^{\\varphi(p)} \\equiv 1$，因此 $a$ 的阶一定存在且有 $\\delta_p(a) \\mid \\varphi(p)$。可以证明\n$$ a,a^2,\\cdots a^{\\delta_p(a)} \\tag{3} $$\n在模 $p$ 下余数互不相同。由 Lagrange 定理，$x^{\\delta_p(a)} \\equiv 1$ 的解至多有 $\\delta_p(a)$ 个，恰是 $(3)$ 中所展示的。\n通过整除的性质，可以想到只有 $i \\bot \\delta_p(a)$ 才有 $\\delta_p(a^i) = \\delta_p(a)$，即 $a$ 总是附带着\n$$ \\sum_{i=1}^{\\delta_p(a)} [\\gcd(i, \\delta_p(a)) = 1] = \\varphi(\\delta_p(a)) $$\n个阶相同的东西。因此阶为 $\\delta_p(a)$ 的数恰有 $\\varphi(\\delta_p(a))$ 个。\n因为每个正整数都有唯一确定的阶，不妨假设对于所有 $d \\mid \\varphi(p)$，阶 $d$ 都存在 $\\varphi(d)$ 个对应的整数，统计整数个数\n$$ \\sum_{d \\mid \\varphi(p)} \\varphi(d) = \\varphi(p) = p - 1 $$\n恰为 $\\mathbb{Z}_p$ 全部正整数的个数，因此假设成立，也就存在 $a$ 使得 $\\delta_p(a) = p-1$。\n我们称这个 $a$ 是模 $p$ 下的一个原根，常用字母 $g$ 表示。\n快速数论变换 尽可能提取 $p - 1$ 的因子 $2$ 有\n$$ p = N q + 1, N = 2^m $$\n设 $\\mathbb{Z}_p$ 的一个原根 $g$，将 $g_N \\equiv g^q$ 看作 $\\zeta_n$ 的等价。利用二次剩余的知识不难得到 $g_N^N \\equiv 1$ 和 $g_N^{N/2} \\equiv -1$。\n常见的有\n$$ \\begin{aligned} p = 1004535809 = 479 \\times 2^{21} + 1\u0026amp;, g = 3 \\\\ p = 998244353 = 7 \\times 17 \\times 2^{23} + 1\u0026amp;, g = 3 \\end{aligned} $$\n类似的，我们可以写出程序\nvoid ntt(ll *f, int n, int type) { for (int i = 0; i \u0026lt; n; ++i) if (i \u0026lt; rev[i]) swap(f[i], f[rev[i]]); for (int h = 2; h \u0026lt; n; h \u0026lt;\u0026lt;= 1) { ll tg = type == 1 ? 3 : g_inv; ll gn = qpow(tg, (P - 1) / h); for (int j = 0; j \u0026lt; n; j += h) { ll g = 1; for (int k = j; k \u0026lt; j + h / 2; k++) { ll f1 = f[k], f2 = g * f[k + h / 2] % P; f[k] = (f1 + f2) % P; f[k + h / 2] = (f1 - f2 + P) % P; g = g * gn % P; } } } ll iv_n = qpow(n); if (type == -1) for (int i = 0; i \u0026lt; n; i++) f[i] = f[i] * iv_n % P; } 至此，你已经学会 FFT 了。下面我们将更深入的从数学角度研究 FFT，补足理论基础。\n线性变换 DFT 是一个线性变换。换句话说，它可以被写成矩阵乘法的形式\n$$ \\begin{bmatrix} f(\\zeta_n^0) \\\\ f(\\zeta_n^1) \\\\ f(\\zeta_n^2) \\\\ \\vdots \\\\ f(\\zeta_n^{n-1}) \\end{bmatrix} = \\begin{bmatrix} 1 \u0026amp; 1 \u0026amp; 1 \u0026amp; \\cdots \u0026amp; 1 \\\\ 1 \u0026amp; \\zeta_n^1 \u0026amp; \\zeta_n^2 \u0026amp; \\cdots \u0026amp; \\zeta_n^{n-1} \\\\ 1 \u0026amp; \\zeta_n^2 \u0026amp; \\zeta_n^4 \u0026amp; \\cdots \u0026amp; \\zeta_n^{2(n-1)} \\\\ \\vdots \u0026amp; \\vdots \u0026amp; \\vdots \u0026amp; \\ddots \u0026amp; \\vdots \\\\ 1 \u0026amp; \\zeta_n^{n-1} \u0026amp; \\zeta_n^{2(n-1)} \u0026amp; \\cdots \u0026amp; \\zeta_n^{(n-1)^2} \\end{bmatrix} \\begin{bmatrix} f_0 \\\\ f_1 \\\\ f_2 \\\\ \\vdots \\\\ f_{n-1} \\end{bmatrix} $$\n我们把中间的那个 $n$ 阶的 Vandermonde 方阵记为 $V(\\zeta_n) = (\\zeta_n^{ij})$。\n直接计算 $V(\\zeta_n)$ 的逆很不好算，但是验证下式是对角矩阵还是容易的\n$$ V(\\zeta_n) V(\\zeta_n^{-1}) = (n[i = j]) = n I_n $$\n即 IDFT 所对应的矩阵为 $V^{-1}(\\zeta_n) = \\frac{1}{n} V(\\zeta_n^{-1})$，我们便证明了 $(1)$ 式。\n干掉 REV 其实上文所实现的 FFT 和 IFFT 并不对偶，只是卷积定理使得 IFFT 恰是 FFT 的逆运算。具体的说，我们实现了两个 DIT，因此需要在计算之前进行蝴蝶变换。\n我们运算的核心内容在于 $(2)$ 式，它可以被写做矩阵形式。\n$$ \\begin{bmatrix} O_1 \\\\ O_2 \\end{bmatrix} = \\begin{bmatrix} 1 \u0026amp; \\zeta_n^{-j} \\\\ 1 \u0026amp; -\\zeta_n^{-j} \\end{bmatrix} \\begin{bmatrix} I_1 \\\\ I_2 \\end{bmatrix} $$\n对矩阵求逆\n$$ \\begin{bmatrix} I_1 \\\\ I_2 \\end{bmatrix} = \\frac{1}{2} \\begin{bmatrix} 1 \u0026amp; 1 \\\\ \\zeta_n^{j} \u0026amp; -\\zeta_n^{j} \\end{bmatrix} \\begin{bmatrix} O_1 \\\\ O_2 \\end{bmatrix} \\tag{4} $$\n我们便得到了 DIF。类似的，我们可以实现两个 DIF 作为 FFT，此时蝴蝶变换在计算之后。\nvoid fft(img *f, int n, int op) { // DIF  for (int l = n / 2; l \u0026gt;= 1; l \u0026gt;\u0026gt;= 1) { img w0 = {cos(PI / l), sin(PI * op / l)}; for (int i = 0; i \u0026lt; n; i += l * 2) { img w = {1, 0}; for (int j = 0; j \u0026lt; l; j++) { img x = f[i + j], y = f[i + j + l]; f[i + j] = x + y, f[i + j + l] = w * (x - y); w = w * w0; } } } for (int i = 0; i \u0026lt; n; ++i) if (i \u0026lt; rev[i]) swap(f[i], f[rev[i]]); if (op == -1) for (int i = 0; i \u0026lt; n; i++) f[i] = f[i] / n; } 容易发现，若我们以 DIF 作为 FFT，DIT 作为 IFFT，是不需要蝴蝶变换的。\nvoid fft(img *f, int n) { for (int l = n / 2; l \u0026gt;= 1; l \u0026gt;\u0026gt;= 1) { img w0 = {cos(PI / l), sin(PI / l)}; for (int i = 0; i \u0026lt; n; i += l * 2) { img w = {1, 0}; for (int j = 0; j \u0026lt; l; j++) { img x = f[i + j], y = f[i + j + l]; f[i + j] = x + y, f[i + j + l] = w * (x - y); w = w * w0; } } } } void ifft(img *f, int n) { for (int l = 1; l \u0026lt;= n / 2; l \u0026lt;\u0026lt;= 1) { img w0 = img{cos(PI / l), sin(PI / l)}.conj(); for (int i = 0; i \u0026lt; n; i += l * 2) { img w = {1, 0}; for (int j = 0; j \u0026lt; l; j++) { img x = f[i + j], y = w * f[i + j + l]; f[i + j] = x + y, f[i + j + l] = x - y; w = w * w0; } } } for (int i = 0; i \u0026lt; n; i++) f[i] = f[i] / n; } 以上，便是 Twisted FFT。\n另一种理解 注意到\n$$ f(x_0) = f \\bmod (x - x_0) $$\n我们可以从这方面着手，从取模角度重新审视上述算法。假设 $f$ 可以被分解为\n$$ f = (x^n - r)(x^n + r)f_{0} + (x^n - r)f_{1} + (x^n + r)f_{2} + f_3 $$\n令\n$$ \\begin{aligned} O_1 \u0026amp;= f \\bmod (x^n + r) = -2r f_1 + f_3\\\\ O_2 \u0026amp;= f \\bmod (x^n - r) = 2r f_2 + f_3 \\end{aligned} $$\n故\n$$ f \\bmod (x^{2n} - r^2) = \\frac{O_2-O_1}{2r}x^n + \\frac{O_2 + O_1}{2} = I_1 x^n + I_2 $$\n注意到代码中我们并没有直接求 $O_1$，而是对第 $j$ 位乘上了 $\\zeta_{2n}^j$，即求的是 $f(\\zeta_{2n}x)$。\n可以发现\n$$ f(\\zeta_{2n}x) \\bmod (x^n-1) = f(\\zeta_{2n}x) \\bmod ((\\zeta_{2n} x)^n - 1) = f(x) \\bmod (x^n + 1) $$\n这个图并不好理解，下面那张 Original FFT 更容易理解，但是现在广为流传的算法是 Twisted FFT。\n通过图可以看出，FFT 的过程即是先把多项式从根推到叶子，即求得所有单位根处的值，做完操作后，再从叶子推回根。\nOriginal FFT 当然，我们可以直接分治，便是 Original FFT。\n由于篇幅有限，本文不展开。\n预处理单位根 每次计算都重新计算一遍单位根太浪费了，这一部分可以预处理。\nvector\u0026lt;img\u0026gt; ROOT; void init(int n) { static int lim = (ROOT = {{1, 0}}, 1); if (lim \u0026gt;= n) return; ROOT.resize(n); for (int l = lim; l \u0026lt; n; l *= 2) { img w = {cos(PI / l / 2), sin(PI / l / 2)}; ROOT[l] = w; for (int i = 1; i \u0026lt; l; ++i) ROOT[i + l] = ROOT[i] * w; } lim = n; } 其他应用 FFT 实际上是一个工具，用于快速计算卷积，这篇文章我想更聚焦于理解 FFT 的计算过程。\nFFT 还有很多应用，比如快速加法，带通配文本匹配等，后面等再刷些题了可能会开一篇讲一讲这个，现在我积累的还不够。\nRefence  OI-Wiki 快速傅里叶变换 FFT 入门笔记 - hly1024  ","permalink":"https://rogeryoungh.github.io/blog/post/learn-fft/","summary":"以下是我对 FFT 的感性理解，可能并不严谨，如有错误欢迎指正。\nFFT 以下讲述的算法是 Cooley–Tukey FFT，它在算法竞赛中使用的更为广泛。\n前置知识：复数，需要理解 Euler 公式。\n多项式乘法 对于 $n$ 次多项式\n$$ \\begin{aligned} f(x) = \\sum_{i=0}^n f_ix^i \u0026amp;= f_0 + f_1 x + f_2x^2 + \\cdots + g_nx^n \\\\ g(x) = \\sum_{i=0}^n g_ix^i \u0026amp;= g_0 + g_1 x + g_2x^2 + \\cdots + g_nx^n \\end{aligned} $$\n它们的卷积是 $F(x) = f(x) \\ast g(x) = (f \\ast g)(x) = \\sum\\limits_{k=0}^{2n} c_kx^k$，其中\n$$ c_k = \\sum_{i+j=k}f_ig_j $$\n因此朴素的计算多项式的卷积需要 $n^2$ 次系数乘法，我们需要优化。","title":"FFT \u0026 NTT 学习笔记"},{"content":"啥也没写，先发两篇 Hello World（\n迁移时遇到了一点问题，在这里记录下。\n修公式 当我把文档从 TeXmacs 转到博客时，发现公式没有渲染，看了半天才明白是下划线被转成 \u0026lt;em\u0026gt; 标签。\n解决办法是创建 Hugo 的 shortcode，可以设定其不被 Markdown 解析。在主题创建 layouts/shortcodes/display-math.html，内容是\n\u0026lt;p\u0026gt; $${{ .Inner }}$$ \u0026lt;/p\u0026gt; 现在行间公式改为如下包裹\n{{\u0026lt; display-math \u0026gt;}} (\\operatorname{DFT}_{\\omega})^{-1} = \\frac{1}{n} (\\operatorname{DFT}_{-1}) {{\u0026lt; /display-math \u0026gt;}} copy 行内公式也是一样，但是因为行内公式很少特别复杂，所以我只改了行间公式。\n","permalink":"https://rogeryoungh.github.io/blog/post/hello-world-hugo/","summary":"啥也没写，先发两篇 Hello World（\n迁移时遇到了一点问题，在这里记录下。\n修公式 当我把文档从 TeXmacs 转到博客时，发现公式没有渲染，看了半天才明白是下划线被转成 \u0026lt;em\u0026gt; 标签。\n解决办法是创建 Hugo 的 shortcode，可以设定其不被 Markdown 解析。在主题创建 layouts/shortcodes/display-math.html，内容是\n\u0026lt;p\u0026gt; $${{ .Inner }}$$ \u0026lt;/p\u0026gt; 现在行间公式改为如下包裹\n{{\u0026lt; display-math \u0026gt;}} (\\operatorname{DFT}_{\\omega})^{-1} = \\frac{1}{n} (\\operatorname{DFT}_{-1}) {{\u0026lt; /display-math \u0026gt;}} copy 行内公式也是一样，但是因为行内公式很少特别复杂，所以我只改了行间公式。","title":"迁移博客到 Hugo"},{"content":"ZAFU 2020 级计算机，在学编程。常用 ID : rogeryoungh。\n喜欢数学和编程，很想认识些有同样兴趣的朋友，欢迎交换友链！\n联系方式 GitHub：rogeryoungh\nTelegram: rogeryoungh\n邮件：rogeryoungh@foxmail.com。\n","permalink":"https://rogeryoungh.github.io/blog/about/","summary":"ZAFU 2020 级计算机，在学编程。常用 ID : rogeryoungh。\n喜欢数学和编程，很想认识些有同样兴趣的朋友，欢迎交换友链！\n联系方式 GitHub：rogeryoungh\nTelegram: rogeryoungh\n邮件：rogeryoungh@foxmail.com。","title":"About"},{"content":"已转 Hugo。\n折腾了一整天，终于把 Hexo 给搭到 GitHub Page 上，我还是太菜了。\n又折腾了一天，使用了新的方式重新部署了博客，那也重写一下 Hello World 吧。\nHexo 本地搭建 装 git 和 npm、换淘宝源。装好之后安装 hexo-cli。\n$ npm install -g hexo-cli 用 hexo 新建目录 blog，进入目录。初始化环境\n$ hexo init blog $ cd blog $ npm install 这时，source/_posts/ 下可以看到 hello-world.md 文档，可以修改试试。\n查看一下成果。\n$ hexo serve 主题配置 最终选定了 Keep，简洁大方，深得我心。\nKeep 的作者给了一个 Demo，就是他自己的博客。还有两篇文档，Keep 主题使用指南 和 Keep 主题配置指南 。这两个文档讲的非常详细，跟着做很容易就配好了。\n然后可以根据文档加入想要的插件，比如我加了 search 和 mathjax 等。\n我决定通过 submodule 的方式使用主题，这样魔改样式时不会污染文章的时间线。\n先 Fork 主题，然后在 blog 项目中引用。\n$ git submodule add https://github.com/RogerYoungh/hexo-theme-keep themes/keep 修改 blog 项目的配置，查看一下主题是否变了。接下来就开始喜闻乐见的魔改主题……此处省略八百字\n主题是独立的项目，更新需要到 themes/keep 目录进行提交。但此时该仓库是游离态，提交修改需要先设置。\n$ git checkout master 之后 add、push 即可提交子模块。\n 有时可能直接在主题仓库中修改提交，而主仓库并不会随之更新依赖版本。此时需要更新子模块\n$ git submodule update --remote --merge  总之，博客仓库中成功拉取主题子模块，之后更新。\n$ git add . $ git submodule 应该可以看到子模块的 SHA 更新了。\nGitHub Action 部署 分别维护代码和网页分支较为麻烦，于是我采用 GitHub Action 做自动部署。\n首先在 _config.yml里设置部署位置\ndeploy:type:gitrepo:https://github.com/用户名/用户名.github.io.gitbranch:gh-page在 Google 直接搜 Hexo GitHub Action，第一个应该就是，按照说明填写信息并配置，push 上去应该就成功了。\n push 当然会报错，根据提示设好上游地址，这里我就偷懒不写啦（\n 现在我们可以在 用户名.github.io 里看到我们的文章啦！\nclone 下来的时候，不要再 hexo init 了，直接 hexo serve，根据提示缺啥包就用 npm install 把包装上。\nGitalk 评论 Keep 的文档讲的已经很清楚了，先请求 OAuth，填写博客地址。我直接把博客地址当 issues 仓库，配置文件里就填博客所在的 Repository 地址。\n部署上去后，博主登录会自动创建 issues。编辑删除等需要到仓库的 issus 地址去操作。\n想了想，还是把评论关了，看着那 issues 闹心，主要也没啥人评论。如果想与我联系的，博客和 GitHub 我都留了邮箱。\n等真有人找我说话了，我再把评论打开吧，不然那么多 issues 都只有我一个人，看着怪可怜的。\nMathJax Test $\\mathrm\\LaTeX$，勾股定理 $a^2+b^2=c^2$，\n$$ \\sum_{n=1}^\\infty \\frac{1}{n^2} = \\frac{\\pi^2}{6} $$\nCode Highlight Test public class Main { public static void main(String args[]) { System.out.println(\u0026#34;Hello World!\u0026#34;); } } ","permalink":"https://rogeryoungh.github.io/blog/post/hello-world-hexo/","summary":"已转 Hugo。\n折腾了一整天，终于把 Hexo 给搭到 GitHub Page 上，我还是太菜了。\n又折腾了一天，使用了新的方式重新部署了博客，那也重写一下 Hello World 吧。\nHexo 本地搭建 装 git 和 npm、换淘宝源。装好之后安装 hexo-cli。\n$ npm install -g hexo-cli 用 hexo 新建目录 blog，进入目录。初始化环境\n$ hexo init blog $ cd blog $ npm install 这时，source/_posts/ 下可以看到 hello-world.md 文档，可以修改试试。\n查看一下成果。\n$ hexo serve 主题配置 最终选定了 Keep，简洁大方，深得我心。\nKeep 的作者给了一个 Demo，就是他自己的博客。还有两篇文档，Keep 主题使用指南 和 Keep 主题配置指南 。这两个文档讲的非常详细，跟着做很容易就配好了。\n然后可以根据文档加入想要的插件，比如我加了 search 和 mathjax 等。\n我决定通过 submodule 的方式使用主题，这样魔改样式时不会污染文章的时间线。\n先 Fork 主题，然后在 blog 项目中引用。","title":"Hexo 搭建记录"}]