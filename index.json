[{"content":"前置知识：复数，需要理解 Euler 公式。\n以下是我对 FFT 的感性理解，可能并不严谨，如有错误欢迎指正。\nFFT 多项式乘法 对于 $n$ 次多项式\n $$ \\begin{aligned} f(x) = \\sum_{i=0}^n f_ix^i \u0026= f_0 + f_1 x + f_2x^2 + \\cdots + g_nx^n \\\\ g(x) = \\sum_{i=0}^n g_ix^i \u0026= g_0 + g_1 x + g_2x^2 + \\cdots + g_nx^n \\end{aligned} $$ 它们的乘法是 $F(x) = f(x)g(x) = \\sum\\limits_{k=0}^{2n} c_kx^k$，其中\n $$ c_k = \\sum_{i+j=k}f_ig_j $$ 因此计算多项式的乘积需要 $n^2$ 次系数乘法，我们需要优化。\n点值表示法 $n$ 次多项式 $f(x)$ 可以由 $n+1$ 个系数决定，也可以由 $n+1$ 个座标（点值）决定。即 $n$ 次多项式可以看作 $n+1$ 维的向量。\n考虑选取 $2n+1$ 个座标来确定 $f(x)$ 和 $g(x)$。则 $F(x)$ 可以简单的通过做 $2n+1$ 次乘法得到\n $$ (x_k,F(x_k)) = \\left(x_k, f(x_k)g(x_k)\\right) $$ 于是求多项式的乘法，可以先从系数表示法转换为点值表示法，做完乘法再变回去。\nDFT 怎么把多项式转换成点值呢？我们有离散 Fourier 变换。称方程 $x^n = 1$ 的 $n$ 个解为单位根。\n设多项式 $f(x) = \\sum\\limits_{k=0}^{n-1} f_kx^k$，并选择一个单位根 $\\omega$，则称向量\n $$ \\operatorname{DFT}_{\\omega}(f) =( f(1), f(\\omega^1), \\cdots, f(\\omega^{n-1}) ) $$ 为 $f$ 的离散 Fourier 变换（Discrete Fourier Transform）。\nDFT 存在逆变换（IDFT），即从点值重新变回系数，仍是从向量到向量的变换。\nIDFT 存在性质\n $$ (\\operatorname{DFT}_{\\omega})^{-1} = \\frac{1}{n} (\\operatorname{DFT}_{{\\omega}^{-1}}) $$ 篇幅所限，不放证明（我不会证）。现在我们可以统一的处理 DFT 和 IDFT。\n单位原根 至此，我们计算 DFT 的复杂度仍然是 $O(n^2)$，其与 FFT 的关键差别就是选取特殊的点加速计算。\n单位根中特殊的一个记作 $\\omega_n = e^{\\frac{2 \\pi i}{n}}$，它叫做单位原根。根据 Euler 公式，有\n $$ \\omega_n = e^{\\tfrac{2 \\pi i}{n}} = \\cos \\left(\\frac{2\\pi}{n}\\right) + i \\sin \\left(\\frac{2\\pi}{n}\\right) $$ 即 $\\omega_n$ 是单位圆上的一个点，全部的 $n$ 个单位根\n $$ x_k = \\omega_n^k = e^{k\\tfrac{2 \\pi i}{n}} = \\cos \\left(\\frac{2\\pi k}{n}\\right) + i \\sin \\left(\\frac{2\\pi k}{n}\\right) $$ 恰全是单位元的 $n$ 等分点。因此根据 Euler 公式，单位根之间的乘法就是在单位元上转圈圈。\n不难通过 Euler 公式验证单位原根 $\\omega_n$ 的几条性质：\n $\\omega_{2n}^{2k} = \\omega_n^k$。 $\\omega_{2n}^{n+k} = -\\omega_{2n}^k$。  分治 利用单位原根的特殊性，我们可以分治计算 DFT。比如对于 $7$ 次多项式\n $$ \\begin{aligned} f(x) \u0026= f_0 + f_1x + f_2x^2 + f_3 x^3 + f_4 x^4 + f_5 x^5 + f_6 x^6 + f_7 x^7 \\\\ \u0026= (f_0 + f_2x^2 + f_4x^4 + f_6x^6) + x(f_1 + f_3x^2 + f_5x^4 + f_7x^6) \\end{aligned} $$ 奇偶分别建立函数\n $$ \\begin{aligned} f^{[0]}(x) \u0026= f_0 + f_2x + f_4x^2 + f_6x^3 \\\\ f^{[1]}(x) \u0026= f_1 + f_3x + f_5x^2 + f_7x^3 \\end{aligned} $$ 则原来的函数可以表示为\n $$ f(x) = f^{[0]}(x^2) + xf^{[1]}(x^2) $$ 一般的，对于度小于 $n$ 的多项式 $f(x)$，利用单位原根的性质有\n $$ \\begin{aligned} f(\\omega_{n}^k) \u0026= f^{[0]}(\\omega_{n}^k \\cdot \\omega_{n}^k) + \\omega_{n}^kf^{[1]}(\\omega_{n}^k \\cdot \\omega_{n}^k) \\\\ \u0026= f^{[0]}(\\omega_{n}^{2k}) + \\omega_{n}^kf^{[1]}(\\omega_{n}^{2k}) \\\\ \u0026= f^{[0]}(\\omega_{n/2}^{k}) + \\omega_{n}^kf^{[1]}(\\omega_{n/2}^{k}) \\end{aligned} $$ 同理可得\n $$ \\begin{aligned} f(\\omega_{n}^{k+n/2}) \u0026= f^{[0]}(\\omega_{n}^{2k+n}) + \\omega_{n}^{k+n/2}f^{[1]}(\\omega_{n}^{2k+n}) \\\\ \u0026= f^{[0]}(\\omega_{n/2}^{k}) - \\omega_{n}^{k}f^{[1]}(\\omega_{n/2}^{k}) \\end{aligned} $$ 因此我们需要把多项式的系数向上补到 $2^n$ 个，方便分治。\n在 DFT 中使用有\n $$ \\begin{aligned} \\operatorname{DFT}_{\\omega}(f)[j] \u0026= \\operatorname{DFT}_{\\omega^2}(f^{[0]})[j] + \\omega^j \\operatorname{DFT}_{\\omega^2}(f^{[1]})[j] \\\\ \\operatorname{DFT}_{\\omega}(f)[j + n/2] \u0026= \\operatorname{DFT}_{\\omega^2}(f^{[0]})[j] - \\omega^j\\operatorname{DFT}_{\\omega^2}(f^{[1]})[j] \\end{aligned} $$ 至此，我们可以写出递归版的 FFT。\nvoid FFT(Comp *f, int n, int type) { if (n == 1) return; for (int i = 0; i \u0026lt; n; i++) tmp[i] = f[i]; for (int i = 0; i \u0026lt; n; i++) { // 偶数放左边，奇数放右边  if (i \u0026amp; 1) f[n / 2 + i / 2] = tmp[i]; else f[i / 2] = tmp[i]; } Comp *g = f, *h = f + n / 2; DFT(g, n / 2, type), DFT(h, n / 2, type); Comp step(cos(2 * PI / n), sin(2 * PI * type / n)), cur(1, 0); for (int k = 0; k \u0026lt; n / 2; k++) { tmp[k] = g[k] + cur * h[k]; tmp[k + n / 2] = g[k] - cur * h[k]; cur = cur * step; } for (int i = 0; i \u0026lt; n; i++) f[i] = tmp[i]; } 蝴蝶变换 递归分治总是不尽人意的，如果能一次到位就更好了。还是以 $7$ 次多项式为例\n 初始 ${x^0,x^1,x^2,x^3,x^4,x^5,x^6,x^7}$ 一次 ${x^0,x^2,x^4,x^6},{x^1,x^3,x^5,x^7}$ 两次 ${x^0,x^4},{x^2,x^6},{x^1,x^5},{x^3,x^7}$ 结束 ${x^0},{x^4},{x^2},{x^6},{x^1},{x^5},{x^3},{x^7}$  写出二进制的形式，可以发现规律\n   初始 0 1 2 3 4 5 6 7     初始(2) 000 001 010 011 100 101 110 111   结束(2) 000 100 010 110 001 101 011 111   结束 0 4 2 6 1 5 3 7    结束和开始的二进制恰好是相反的。这个变换称为蝴蝶变换，也称位逆序置换（bit-reversal permutation）。\n我们可以 $O(n)$ 的预处理出变换数组。设 R(x) 是 $x$ 的变换结果，则 R(x\u0026gt;\u0026gt;1) 是已求的。\n $$ \\begin{aligned} \\texttt{000abcd} \u0026\\to \\texttt{dcba000} \\\\ \\texttt{00abcdx} \u0026\\to \\texttt{xdcba00} \\end{aligned} $$ 即是把 R(x\u0026gt;\u0026gt;1) 右移一位再补上最高位即可。代码如下\nint lim = 1, lim_2; while (lim \u0026lt;= n + m) lim \u0026lt;\u0026lt;= 1; lim_2 = lim \u0026gt;\u0026gt; 1; for (int i = 0; i \u0026lt; lim; ++i) { rev[i] = rev[i \u0026gt;\u0026gt; 1] \u0026gt;\u0026gt; 1; if (i \u0026amp; 1) rev[i] |= lim \u0026gt;\u0026gt; 1; // 或者合并写为  // rev[i] = (rev[i \u0026gt;\u0026gt; 1] \u0026gt;\u0026gt; 1) | ((i \u0026amp; 1) * lim_2); } 现在我们可以写出非递归版的 FFT。\nvoid FFT(Comp *f, int n, int type) { for (int i = 0; i \u0026lt; n; ++i) { if (i \u0026lt; rev[i]) { swap(f[i], f[rev[i]]); } } for (int h = 2; h \u0026lt;= n; h \u0026lt;\u0026lt;= 1) { Comp step(cos(2 * PI / h), sin(2 * PI * type / h)); for (int j = 0; j \u0026lt; n; j += h) { Comp cur(1, 0); for (int k = j; k \u0026lt; j + h / 2; k++) { Comp f1 = f[k], f2 = cur * f[k + h / 2]; f[k] = f1 + f2; f[k + h / 2] = f1 - f2; cur = cur * step; } } } if (type == 1) return; for (int i = 0; i \u0026lt; n; i++) f[i].x /= n, f[i].y /= n; } NTT 前置知识：数论基础（整除，同余）。\n用 double 去实现整数的乘法是很不优美的，精度、速度都很成问题。实际上，我们可以仅在整数下进行运算。\n原根 我们本质上用到的单位原根 $\\omega_n$ 的两个性质是：\n $\\omega_{n}^{n} = 1$。 $\\omega_{2n}^{n} = -1$。  可以联想到模 $p$ 剩余类域 $\\mathbb{Z}_p$：其中的元素是 $\\{0,1,\\cdots,p-1\\}$，其上的运算都是模 $p$ 的。由于 Fermat 小定理\n $$ a^{\\varphi(p)} = a^{p-1} \\equiv 1 $$ 即从另一个角度说，$p-1$ 个正整数都是同余方程 $x^{p-1} \\equiv 1$ 的解。\n它和单位根有很相似的形式，直觉上 $\\mathbb{Z}_p$ 也存在类似单位原根的特殊数字。下面我们在 $\\mathbb{Z}_p$ 上讨论，尝试证明这个数字存在。\n定义正整数 $a \\in \\mathbb{Z}_p$ 的阶 $\\delta_p(a)$ 为最小的 $r$ 使得 $a^r \\equiv 1$。由 Fermat 小定理 $a^{\\varphi(p)} \\equiv 1$，因此 $a$ 的阶一定存在且有 $\\delta_p(a) \\mid \\varphi(p)$。可以证明\n $$ a,a^2,\\cdots a^{\\delta_p(a)} \\tag{1} $$ 在模 $p$ 下余数互不相同。由 Lagrange 定理，$x^{\\delta_p(a)} \\equiv 1$ 的解至多有 $\\delta_p(a)$ 个，恰是 $(1)$ 中所展示的。\n通过整除的性质，可以想到只有 $i \\bot \\delta_p(a)$ 才有 $\\delta_p(a^i) = \\delta_p(a)$，即 $a$ 总是附带着\n $$ \\sum_{i=1}^{\\delta_p(a)} [\\gcd(i, \\delta_p(a)) = 1] = \\varphi(\\delta_p(a)) $$ 个阶相同的东西。因此阶为 $\\delta_p(a)$ 的数恰有 $\\varphi(\\delta_p(a))$ 个。\n因为每个正整数都有唯一确定的阶，不妨假设对于所有 $d \\mid \\varphi(p)$，阶 $d$ 都存在 $\\varphi(d)$ 个对应的整数，统计整数个数\n $$ \\sum_{d \\mid \\varphi(p)} \\varphi(d) = \\varphi(p) = p - 1 $$ 恰为 $\\mathbb{Z}_p$ 全部正整数的个数，因此假设成立，也就存在 $a$ 使得 $\\delta_p(a) = p-1$。\n我们称这个 $a$ 是模 $p$ 下的一个原根，常用字母 $g$ 表示。\n快速数论变换 尽可能提取 $p - 1$ 的因子 $2$ 有\n $$ p = N q + 1, N = 2^m $$ 设 $\\mathbb{Z}_p$ 的一个原根 $g$，将 $g_N \\equiv g^q$ 看作 $\\omega_n$ 的等价。利用二次剩余的知识不难得到 $g_N^N \\equiv 1$ 和 $g_N^{N/2} \\equiv -1$。\n常见的有\n $$ \\begin{aligned} p = 1004535809 = 479 \\times 2^{21} + 1\u0026, g = 3 \\\\ p = 998244353 = 7 \\times 17 \\times 2^{23} + 1\u0026, g = 3 \\end{aligned} $$ 类似的，我们可以写出程序\nvoid NTT(ll *f, int n, int type) { for (int i = 0; i \u0026lt; n; ++i) { if (i \u0026lt; rev[i]) { swap(f[i], f[rev[i]]); } } for (int h = 2; h \u0026lt;= n; h \u0026lt;\u0026lt;= 1) { ll tg = type == 1 ? 3 : g_inv; ll gn = qpow(tg, (mod - 1) / h); for (int j = 0; j \u0026lt; n; j += h) { ll g = 1; for (int k = j; k \u0026lt; j + h / 2; k++) { ll f1 = f[k], f2 = g * f[k + h / 2] % mod; f[k] = mo(f1 + f2); f[k + h / 2] = mo(f1 - f2); g = g * gn % mod; } } } if (type == 1) return; ll lim_inv = inv(n); for (int i = 0; i \u0026lt; n; i++) f[i] = f[i] * lim_inv % mod; } 拆系数 FFT 如果需要更高的精度，可以考虑拆系数 FFT。\n给定多项式 $A(x), B(x)$，再给出 $m = 2^{15}$ 拆分\n $$ \\begin{aligned} A(x) \u0026 = m A_1(x) + A_0(x)\\\\ B(x) \u0026 = m B_1(x) + B_0(x) \\end{aligned} $$ 最终的乘法是\n $$ A B = m^2 A_1 B_1 + m (A_1 B_0 + A_0 B_1) + A_0 B_0 $$ 可以看到，我们要做 4 次 DFT 和 3 次 IDFT 。\n实现一 构造\n $$ P = A + i B, Q = A - i B $$ 乘法有\n $$ \\operatorname{DFT} (P) = \\operatorname{DFT} (A) + i \\operatorname{DFT} (B) $$ 由于 $A, B$ 都是实多项式，注意到共轭复数的性质：$\\operatorname{conj} (z_1) \\operatorname{cosj} (z_2) = \\operatorname{conj} (z_1 z_2)$，代入有\n $$ \\operatorname{conj} (\\operatorname{DFT} (P) [j]) = \\operatorname{conj} (P (\\omega^j)) = \\operatorname{conj} (P) \\operatorname{conj} (\\omega^j) = Q (\\omega^{n - j}) = \\operatorname{DFT} (Q) [n - j] $$ 因此 2 次 DFT 可以被优化到 1 次。\nvoid FFTFFT(Comp *a, Comp *b, int len, int t) { for (int i = 0; i \u0026lt; lim; i++) a[i] = a[i] + I * b[i]; FFT(a, len, t); for (int i = 0; i \u0026lt; lim; i++) b[i] = a[i ? lim - i : 0].conj(); for (int i = 0; i \u0026lt; lim; i++) { Comp p = a[i], q = b[i]; a[i] = (p + q) * 0.5; b[i] = (q - p) * 0.5 * I; } } 故 2 次 DFT 和 2 次 IDFT。\nint main() { //...  FFT_init(lim); FFTFFT(a0, a1, lim, 1); FFTFFT(b0, b1, lim, 1); for (int i = 0; i \u0026lt; lim; i++) { p[i] = a0[i] * b0[i] + I * a1[i] * b0[i]; q[i] = a0[i] * b1[i] + I * a1[i] * b1[i]; } FFT(p, lim, -1); FFT(q, lim, -1); for (int i = 0; i \u0026lt;= n + m; i++) { ll a1b1 = ld2ll(p[i].x) % mod; ll a1b0 = ld2ll(p[i].y) % mod; ll a0b1 = ld2ll(q[i].x) % mod; ll a0b0 = ld2ll(q[i].y) % mod; ll ans = ((tLIM * a1b1 + (a1b0 + a0b1)) * tLIM + a0b0) % mod; printf(\u0026#34;%lld \u0026#34;, (ans + mod) % mod); } //... } 实现二 还有另一种拆法。设\n $$ P_1 = A_1 + i A_0, P_2 = A_1 - i A_0, Q = B_1 + i B_0 $$ 乘法有\n $$ \\begin{aligned} T_1 = P_1 Q \u0026 = A_1 B_1 - A_0 B_0 + i (A_1 B_0 + A_0 B_1)\\\\ T_2 = P_2 Q \u0026 = A_1 B_1 + A_0 B_0 + i (A_1 B_0 - A_0 B_1) \\end{aligned} $$ 可以很容易的从中分离出我们需要的系数。故 3 次 DFT，2 次 IDFT。\n此方法实现简单，理解容易，而且常数较小，不输 4 次 DFT。（也可能是我姿势不对）\nint main() { //...  FFT_init(lim); FFT(P1, lim, 1); FFT(P2, lim, 1); FFT(Q, lim, 1); for (int i = 0; i \u0026lt; lim; i++) P1[i] = P1[i] * Q[i]; for (int i = 0; i \u0026lt; lim; i++) P2[i] = P2[i] * Q[i]; FFT(P1, lim, -1); FFT(P2, lim, -1); for (int i = 0; i \u0026lt;= m + n; i++) { ll a1b1 = ld2ll((P1[i].x + P2[i].x) / 2) % p; ll a1b2 = ld2ll((P1[i].y + P2[i].y) / 2) % p; ll a2b1 = ld2ll((P1[i].y - P2[i].y) / 2) % p; ll a2b2 = ld2ll((P2[i].x - P1[i].x) / 2) % p; ll ans = ((a1b1 * tLIM + (a1b2 + a2b1)) * tLIM + a2b2) % p; printf(\u0026#34;%lld \u0026#34;, (ans + p) % p); } //... } 应用 FFT P3803 多项式乘法 实战一下：P3803 多项式乘法。\n我们的计算步骤是：\nFFT(F, lim, 1); FFT(G, lim, 1); for (int i = 0; i \u0026lt;= lim; i++) F[i] = F[i] * G[i]; FFT(F, lim, -1); 实际上，我们并不用三次 FFT，两次足以。注意到若把 $F(x)$ 放在实部而 $G(x)$ 放在虚部\n $$ (F + iG)^2 = (F^2-G^2) + 2iFG $$ 平方之后虚部恰是答案。\n这里展示全部的代码，帮助大家理解。\nFFT 模板（P3803 多项式乘法） const double PI = acos(-1.0); const int MAXN = 4e6 + 10; struct Comp { double x, y; Comp(double xx = 0, double yy = 0) { x = xx, y = yy; } Comp operator+(Comp c) { return Comp(x + c.x, y + c.y); } Comp operator-(Comp c) { return Comp(x - c.x, y - c.y); } Comp operator*(Comp c) { double tx = x * c.x - y * c.y; double ty = x * c.y + y * c.x; return Comp(tx, ty); } }; Comp ff[MAXN]; int rev[MAXN]; void FFT(Comp *f, int n, int type) { for (int i = 0; i \u0026lt; n; ++i) { if (i \u0026lt; rev[i]) { swap(f[i], f[rev[i]]); } } for (int h = 2; h \u0026lt;= n; h \u0026lt;\u0026lt;= 1) { Comp step(cos(2 * PI / h), sin(2 * PI * type / h)); for (int j = 0; j \u0026lt; n; j += h) { Comp cur(1, 0); for (int k = j; k \u0026lt; j + h / 2; k++) { Comp f1 = f[k], f2 = f[k + h / 2]; f[k] = f1 + cur * f2; f[k + h / 2] = f1 - cur * f2; cur = cur * step; } } } if (type == 1) return; for (int i = 0; i \u0026lt; n; i++) f[i].x /= n, f[i].y /= n; } int main() { int n = rr(), m = rr(); for (int i = 0; i \u0026lt;= n; i++) ff[i].x = rr(); for (int i = 0; i \u0026lt;= m; i++) ff[i].y = rr(); int lim = 1, lim_2; while (lim \u0026lt;= n + m) lim \u0026lt;\u0026lt;= 1; lim_2 = lim \u0026gt;\u0026gt; 1; for (int i = 0; i \u0026lt; lim; ++i) rev[i] = (rev[i \u0026gt;\u0026gt; 1] \u0026gt;\u0026gt; 1) | ((i \u0026amp; 1) * lim_2); FFT(ff, lim, 1); for (int i = 0; i \u0026lt;= lim; i++) ff[i] = ff[i] * ff[i]; FFT(ff, lim, -1); for (int i = 0; i \u0026lt;= m + n; i++) printf(\u0026#34;%d \u0026#34;, int(ff[i].y / 2 + 0.5)); return 0; }    NTT P3803 多项式乘法 NTT 再来一遍。\nNTT 模板（P3803 多项式乘法） const ll mod = 998244353, g = 3; const ll MAXN = 4e6 + 10; ll qpow(ll a, ll b, ll p = mod) { ll ret = p != 1; for (; b; b \u0026gt;\u0026gt;= 1) { if (b \u0026amp; 1) ret = a * ret % p; a = a * a % p; } return ret; } ll inv(ll a) { return qpow(a, mod - 2); } ll mo(ll n) { return (n + mod) % mod; } const ll g_inv = inv(g); ll ff[MAXN], gg[MAXN]; int rev[MAXN]; void NTT(ll *f, int n, int type) { for (int i = 0; i \u0026lt; n; ++i) { if (i \u0026lt; rev[i]) { swap(f[i], f[rev[i]]); } } for (int h = 2; h \u0026lt;= n; h \u0026lt;\u0026lt;= 1) { ll tg = type == 1 ? 3 : g_inv; ll gn = qpow(tg, (mod - 1) / h); for (int j = 0; j \u0026lt; n; j += h) { ll g = 1; for (int k = j; k \u0026lt; j + h / 2; k++) { ll f1 = f[k], f2 = g * f[k + h / 2] % mod; f[k] = mo(f1 + f2); f[k + h / 2] = mo(f1 - f2); g = g * gn % mod; } } } if (type == 1) return; ll lim_inv = inv(n); for (int i = 0; i \u0026lt; n; i++) f[i] = f[i] * lim_inv % mod; } int main() { int n = rr(), m = rr(); for (int i = 0; i \u0026lt;= n; i++) ff[i] = rr(); for (int i = 0; i \u0026lt;= m; i++) gg[i] = rr(); int lim = 1, lim_2; while (lim \u0026lt;= n + m) lim \u0026lt;\u0026lt;= 1; lim_2 = lim \u0026gt;\u0026gt; 1; for (int i = 0; i \u0026lt; lim; ++i) rev[i] = (rev[i \u0026gt;\u0026gt; 1] \u0026gt;\u0026gt; 1) | ((i \u0026amp; 1) * lim_2); NTT(ff, lim, 1); NTT(gg, lim, 1); for (int i = 0; i \u0026lt;= lim; i++) ff[i] = ff[i] * gg[i]; NTT(ff, lim, -1); for (int i = 0; i \u0026lt;= m + n; i++) printf(\u0026#34;%lld \u0026#34;, ff[i]); return 0; }    FFT P4245 任意模数多项式乘法 实现一。\n拆系数 FFT 模板（实现一，P4245 任意模数多项式乘法） const ll MAXN = 4e5 + 10; const ll tLIM = 1 \u0026lt;\u0026lt; 15; const long double PI = acos(-1); struct Comp { ld x, y; Comp(ld xx = 0, ld yy = 0) { x = xx, y = yy; } Comp operator+(Comp c) { return Comp(x + c.x, y + c.y); } Comp operator-(Comp c) { return Comp(x - c.x, y - c.y); } Comp operator*(Comp c) { ld tx = x * c.x - y * c.y; ld ty = x * c.y + y * c.x; return Comp(tx, ty); } Comp conj(int type = -1) { return Comp(x, type * y); } }; Comp I(0, 1); int rev[MAXN]; Comp Wn[MAXN]; void FFT(Comp *f, int n, int type) { for (int i = 0; i \u0026lt; n; ++i) { if (i \u0026lt; rev[i]) { swap(f[i], f[rev[i]]); } } for (int h = 2; h \u0026lt;= n; h \u0026lt;\u0026lt;= 1) { Comp step = Wn[h].conj(type); for (int j = 0; j \u0026lt; n; j += h) { Comp cur(1, 0); for (int k = j; k \u0026lt; j + h / 2; k++) { Comp f1 = f[k], f2 = f[k + h / 2]; f[k] = f1 + cur * f2; f[k + h / 2] = f1 - cur * f2; cur = cur * step; } } } if (type == 1) return; for (int i = 0; i \u0026lt; n; i++) f[i].x /= n, f[i].y /= n; } int mod; inline void FFTFFT(Comp *a, Comp *b, int len, int t) { for (int i = 0; i \u0026lt; len; i++) a[i] = a[i] + I * b[i]; FFT(a, len, t); for (int i = 0; i \u0026lt; len; i++) b[i] = a[i ? len - i : 0].conj(); for (int i = 0; i \u0026lt; len; i++) { Comp p = a[i], q = b[i]; a[i] = (p + q) * 0.5; b[i] = (q - p) * 0.5 * I; } } Comp a0[MAXN], a1[MAXN], b0[MAXN], b1[MAXN]; Comp p[MAXN], q[MAXN]; void FFT_init(ll lim) { ll lim_2 = lim \u0026gt;\u0026gt; 1; for (int i = 0; i \u0026lt; lim; ++i) rev[i] = (rev[i \u0026gt;\u0026gt; 1] \u0026gt;\u0026gt; 1) | ((i \u0026amp; 1) * lim_2); for (int i = 1; i \u0026lt;= lim; ++i) Wn[i] = Comp(cos(2 * PI / i), sin(2 * PI / i)); } ll ld2ll(ld n) { return ll(n + 0.5); } int main() { int n = rr(), m = rr(); mod = rr(); for (int i = 0; i \u0026lt;= n; i++) { int x = rr() % mod; a0[i].x = x / tLIM; a1[i].x = x % tLIM; } for (int i = 0; i \u0026lt;= m; i++) { int x = rr() % mod; b0[i].x = x / tLIM; b1[i].x = x % tLIM; } int lim = 1; while (lim \u0026lt; n + m + 1) lim \u0026lt;\u0026lt;= 1; FFT_init(lim); FFTFFT(a0, a1, lim, 1); FFTFFT(b0, b1, lim, 1); for (int i = 0; i \u0026lt; lim; i++) { p[i] = a0[i] * b0[i] + I * a1[i] * b0[i]; q[i] = a0[i] * b1[i] + I * a1[i] * b1[i]; } FFT(p, lim, -1); FFT(q, lim, -1); for (int i = 0; i \u0026lt;= n + m; i++) { ll a1b1 = ld2ll(p[i].x) % mod; ll a1b0 = ld2ll(p[i].y) % mod; ll a0b1 = ld2ll(q[i].x) % mod; ll a0b0 = ld2ll(q[i].y) % mod; ll ans = ((tLIM * a1b1 + (a1b0 + a0b1)) * tLIM + a0b0) % mod; printf(\u0026#34;%lld \u0026#34;, (ans + mod) % mod); } return 0; }    实现二。\n拆系数 FFT 模板（实现二，P4245 任意模数多项式乘法） const ll MAXN = 4e5 + 10; const ll tLIM = 1 \u0026lt;\u0026lt; 15; const long double PI = acos(-1); int n, m, p, rev[MAXN]; struct Comp { ld x, y; Comp(ld xx = 0, ld yy = 0) { x = xx, y = yy; } Comp operator+(Comp c) { return Comp(x + c.x, y + c.y); } Comp operator-(Comp c) { return Comp(x - c.x, y - c.y); } Comp operator*(Comp c) { ld tx = x * c.x - y * c.y; ld ty = x * c.y + y * c.x; return Comp(tx, ty); } Comp conj(int type = -1) { return Comp(x, type * y); } }; Comp P1[MAXN], P2[MAXN], Q[MAXN], Wn[MAXN]; void FFT(Comp *f, int n, int type) { for (int i = 0; i \u0026lt; n; ++i) { if (i \u0026lt; rev[i]) { swap(f[i], f[rev[i]]); } } for (int h = 2; h \u0026lt;= n; h \u0026lt;\u0026lt;= 1) { Comp step = Wn[h].conj(type); for (int j = 0; j \u0026lt; n; j += h) { Comp cur(1, 0); for (int k = j; k \u0026lt; j + h / 2; k++) { Comp f1 = f[k], f2 = f[k + h / 2]; f[k] = f1 + cur * f2; f[k + h / 2] = f1 - cur * f2; cur = cur * step; } } } if (type == 1) return; for (int i = 0; i \u0026lt; n; i++) f[i].x /= n, f[i].y /= n; } ll ld2ll(ld n) { return ll(n + 0.5); } void FFT_init(ll lim) { ll lim_2 = lim \u0026gt;\u0026gt; 1; for (int i = 0; i \u0026lt; lim; ++i) rev[i] = (rev[i \u0026gt;\u0026gt; 1] \u0026gt;\u0026gt; 1) | ((i \u0026amp; 1) * lim_2); for (int i = 1; i \u0026lt;= lim; ++i) Wn[i] = Comp(cos(2 * PI / i), sin(2 * PI / i)); } int main() { scanf(\u0026#34;%d%d%d\u0026#34;, \u0026amp;n, \u0026amp;m, \u0026amp;p); for (int i = 0; i \u0026lt;= n; i++) { ll t = rr(); P1[i] = Comp(t / tLIM, t % tLIM); P2[i] = Comp(t / tLIM, -t % tLIM); } for (int i = 0; i \u0026lt;= m; i++) { ll t = rr(); Q[i] = Comp(t / tLIM, t % tLIM); } int lim = 1, lim_2; while (lim \u0026lt;= n + m) lim \u0026lt;\u0026lt;= 1; FFT_init(lim); FFT(P1, lim, 1); FFT(P2, lim, 1); FFT(Q, lim, 1); for (int i = 0; i \u0026lt; lim; i++) P1[i] = P1[i] * Q[i]; for (int i = 0; i \u0026lt; lim; i++) P2[i] = P2[i] * Q[i]; FFT(P1, lim, -1); FFT(P2, lim, -1); for (int i = 0; i \u0026lt;= m + n; i++) { ll a1b1 = ld2ll((P1[i].x + P2[i].x) / 2) % p; ll a1b2 = ld2ll((P1[i].y + P2[i].y) / 2) % p; ll a2b1 = ld2ll((P1[i].y - P2[i].y) / 2) % p; ll a2b2 = ld2ll((P2[i].x - P1[i].x) / 2) % p; ll ans = ((a1b1 * tLIM + (a1b2 + a2b1)) * tLIM + a2b2) % p; printf(\u0026#34;%lld \u0026#34;, (ans + p) % p); } return 0; }    其他应用 FFT 实际上是一个工具，用于快速计算卷积，这篇文章我想更聚焦于理解 FFT 的计算过程。\nFFT 还有很多应用，比如快速加法，带通配文本匹配等，后面等再刷些题了可能会开一篇讲一讲这个，现在我积累的还不够。\n","permalink":"https://rogeryoungh.github.io/blog/post/learn-fft/","summary":"前置知识：复数，需要理解 Euler 公式。\n以下是我对 FFT 的感性理解，可能并不严谨，如有错误欢迎指正。\nFFT 多项式乘法 对于 $n$ 次多项式\n $$ \\begin{aligned} f(x) = \\sum_{i=0}^n f_ix^i \u0026= f_0 + f_1 x + f_2x^2 + \\cdots + g_nx^n \\\\ g(x) = \\sum_{i=0}^n g_ix^i \u0026= g_0 + g_1 x + g_2x^2 + \\cdots + g_nx^n \\end{aligned} $$ 它们的乘法是 $F(x) = f(x)g(x) = \\sum\\limits_{k=0}^{2n} c_kx^k$，其中\n $$ c_k = \\sum_{i+j=k}f_ig_j $$ 因此计算多项式的乘积需要 $n^2$ 次系数乘法，我们需要优化。\n点值表示法 $n$ 次多项式 $f(x)$ 可以由 $n+1$ 个系数决定，也可以由 $n+1$ 个座标（点值）决定。即 $n$ 次多项式可以看作 $n+1$ 维的向量。","title":"FFT \u0026 NTT 学习笔记"},{"content":"啥也没写，先发两篇 Hello World（\n迁移时遇到了一点问题，在这里记录下。\n修公式 当我把文档从 TeXmacs 转到博客时，发现公式没有渲染，看了半天才明白是下划线被转成 \u0026lt;em\u0026gt; 标签。\n解决办法是创建 Hugo 的 shortcode，可以设定其不被 Markdown 解析。在主题创建 layouts/shortcodes/display-math.html，内容是\n\u0026lt;p\u0026gt; $${{ .Inner }}$$ \u0026lt;/p\u0026gt; 现在行间公式改为如下包裹\n{{\u0026lt; display-math \u0026gt;}} (\\operatorname{DFT}_{\\omega})^{-1} = \\frac{1}{n} (\\operatorname{DFT}_{-1}) {{\u0026lt; /display-math \u0026gt;}} copy 行内公式也是一样，但是因为行内公式很少特别复杂，所以我只改了行间公式。\n","permalink":"https://rogeryoungh.github.io/blog/post/hello-world-hugo/","summary":"啥也没写，先发两篇 Hello World（\n迁移时遇到了一点问题，在这里记录下。\n修公式 当我把文档从 TeXmacs 转到博客时，发现公式没有渲染，看了半天才明白是下划线被转成 \u0026lt;em\u0026gt; 标签。\n解决办法是创建 Hugo 的 shortcode，可以设定其不被 Markdown 解析。在主题创建 layouts/shortcodes/display-math.html，内容是\n\u0026lt;p\u0026gt; $${{ .Inner }}$$ \u0026lt;/p\u0026gt; 现在行间公式改为如下包裹\n{{\u0026lt; display-math \u0026gt;}} (\\operatorname{DFT}_{\\omega})^{-1} = \\frac{1}{n} (\\operatorname{DFT}_{-1}) {{\u0026lt; /display-math \u0026gt;}} copy 行内公式也是一样，但是因为行内公式很少特别复杂，所以我只改了行间公式。","title":"迁移博客到 Hugo"},{"content":"ZAFU 2020 级计算机，在学编程。常用 ID : rogeryoungh。\n喜欢数学和编程，很想认识些有同样兴趣的朋友，欢迎交换友链！\n联系方式 GitHub：rogeryoungh\nTelegram: rogeryoungh\n邮件：rogeryoungh@foxmail.com。\n","permalink":"https://rogeryoungh.github.io/blog/about/","summary":"ZAFU 2020 级计算机，在学编程。常用 ID : rogeryoungh。\n喜欢数学和编程，很想认识些有同样兴趣的朋友，欢迎交换友链！\n联系方式 GitHub：rogeryoungh\nTelegram: rogeryoungh\n邮件：rogeryoungh@foxmail.com。","title":"About"},{"content":"已转 Hugo。\n折腾了一整天，终于把 Hexo 给搭到 GitHub Page 上，我还是太菜了。\n又折腾了一天，使用了新的方式重新部署了博客，那也重写一下 Hello World 吧。\nHexo 本地搭建 装 git 和 npm、换淘宝源。装好之后安装 hexo-cli。\n$ npm install -g hexo-cli 用 hexo 新建目录 blog，进入目录。初始化环境\n$ hexo init blog $ cd blog $ npm install 这时，source/_posts/ 下可以看到 hello-world.md 文档，可以修改试试。\n查看一下成果。\n$ hexo serve 主题配置 最终选定了 Keep，简洁大方，深得我心。\nKeep 的作者给了一个 Demo，就是他自己的博客。还有两篇文档，Keep 主题使用指南 和 Keep 主题配置指南 。这两个文档讲的非常详细，跟着做很容易就配好了。\n然后可以根据文档加入想要的插件，比如我加了 search 和 mathjax 等。\n我决定通过 submodule 的方式使用主题，这样魔改样式时不会污染文章的时间线。\n先 Fork 主题，然后在 blog 项目中引用。\n$ git submodule add https://github.com/RogerYoungh/hexo-theme-keep themes/keep 修改 blog 项目的配置，查看一下主题是否变了。接下来就开始喜闻乐见的魔改主题……此处省略八百字\n主题是独立的项目，更新需要到 themes/keep 目录进行提交。但此时该仓库是游离态，提交修改需要先设置。\n$ git checkout master 之后 add、push 即可提交子模块。\n 有时可能直接在主题仓库中修改提交，而主仓库并不会随之更新依赖版本。此时需要更新子模块\n$ git submodule update --remote --merge  总之，博客仓库中成功拉取主题子模块，之后更新。\n$ git add . $ git submodule 应该可以看到子模块的 SHA 更新了。\nGitHub Action 部署 分别维护代码和网页分支较为麻烦，于是我采用 GitHub Action 做自动部署。\n首先在 _config.yml里设置部署位置\ndeploy:type:gitrepo:https://github.com/用户名/用户名.github.io.gitbranch:gh-page在 Google 直接搜 Hexo GitHub Action，第一个应该就是，按照说明填写信息并配置，push 上去应该就成功了。\n push 当然会报错，根据提示设好上游地址，这里我就偷懒不写啦（\n 现在我们可以在 用户名.github.io 里看到我们的文章啦！\nclone 下来的时候，不要再 hexo init 了，直接 hexo serve，根据提示缺啥包就用 npm install 把包装上。\nGitalk 评论 Keep 的文档讲的已经很清楚了，先请求 OAuth，填写博客地址。我直接把博客地址当 issues 仓库，配置文件里就填博客所在的 Repository 地址。\n部署上去后，博主登录会自动创建 issues。编辑删除等需要到仓库的 issus 地址去操作。\n想了想，还是把评论关了，看着那 issues 闹心，主要也没啥人评论。如果想与我联系的，博客和 GitHub 我都留了邮箱。\n等真有人找我说话了，我再把评论打开吧，不然那么多 issues 都只有我一个人，看着怪可怜的。\nMathJax Test $\\mathrm\\LaTeX$，勾股定理 $a^2+b^2=c^2$，\n$$ \\sum_{n=1}^\\infty \\frac{1}{n^2} = \\frac{\\pi^2}{6} $$\nCode Highlight Test public class Main { public static void main(String args[]) { System.out.println(\u0026#34;Hello World!\u0026#34;); } } ","permalink":"https://rogeryoungh.github.io/blog/post/hello-world-hexo/","summary":"已转 Hugo。\n折腾了一整天，终于把 Hexo 给搭到 GitHub Page 上，我还是太菜了。\n又折腾了一天，使用了新的方式重新部署了博客，那也重写一下 Hello World 吧。\nHexo 本地搭建 装 git 和 npm、换淘宝源。装好之后安装 hexo-cli。\n$ npm install -g hexo-cli 用 hexo 新建目录 blog，进入目录。初始化环境\n$ hexo init blog $ cd blog $ npm install 这时，source/_posts/ 下可以看到 hello-world.md 文档，可以修改试试。\n查看一下成果。\n$ hexo serve 主题配置 最终选定了 Keep，简洁大方，深得我心。\nKeep 的作者给了一个 Demo，就是他自己的博客。还有两篇文档，Keep 主题使用指南 和 Keep 主题配置指南 。这两个文档讲的非常详细，跟着做很容易就配好了。\n然后可以根据文档加入想要的插件，比如我加了 search 和 mathjax 等。\n我决定通过 submodule 的方式使用主题，这样魔改样式时不会污染文章的时间线。\n先 Fork 主题，然后在 blog 项目中引用。","title":"Hexo 搭建记录"}]